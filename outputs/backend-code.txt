===== api/types/database.types.ts =====
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      recipes: {
        Row: {
          id: string
          created_at: string
          title: string
          servings: number
          user_id?: string
        }
        Insert: {
          id?: string
          title: string
          servings: number
          user_id?: string
        }
        Update: {
          id?: string
          title?: string
          servings?: number
          user_id?: string
        }
      }
      ingredients: {
        Row: {
          id: string
          recipe_id: string
          name: string
          amount: string
          unit: string
          adjustable: boolean
          created_at: string
        }
        Insert: {
          id?: string
          recipe_id: string
          name: string
          amount: string
          unit: string
          adjustable: boolean
        }
        Update: {
          recipe_id?: string
          name?: string
          amount?: string
          unit?: string
          adjustable?: boolean
        }
      }
      substitutions: {
        Row: {
          id: string
          ingredient_id: string
          name: string
          description: string
          created_at: string
        }
        Insert: {
          id?: string
          ingredient_id: string
          name: string
          description: string
        }
        Update: {
          ingredient_id?: string
          name?: string
          description?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
}


===== api/types/scraperapi-sdk.d.ts =====
declare module 'scraperapi-sdk' {
  interface ScraperAPIClient {
    get: (url: string, options?: any) => Promise<any>; // You might want to refine 'any' to a more specific type if you know the response structure
    // Add other methods if you use them, e.g.:
    // post: (url: string, data: any, options?: any) => Promise<any>;
    // put: (url: string, data: any, options?: any) => Promise<any>;
  }

  function scraperapiClient(apiKey: string): ScraperAPIClient;
  export default scraperapiClient;
} 

===== api/utils/usageUtils.ts =====
// Type definition for standardized usage data
export type StandardizedUsage = {
    inputTokens: number;
    outputTokens: number;
};

// Type definition for Gemini's specific usage metadata structure (adjust if needed based on actual SDK)
// Assuming it might be nested or null
type GeminiUsageMetadata = {
    promptTokenCount?: number;
    candidatesTokenCount?: number;
    totalTokenCount?: number; // Example of another potential field
} | null | undefined;

/**
 * Normalizes usage metadata from different potential AI providers (currently Gemini) 
 * into a standard format.
 * 
 * @param metadata The usage metadata object from the AI provider's response.
 * @param provider The provider name (e.g., 'gemini') - for future use.
 * @returns A StandardizedUsage object.
 */
export function normalizeUsageMetadata(
    metadata: GeminiUsageMetadata,
    provider: string = 'gemini' // Default to gemini for now
): StandardizedUsage {
    const usage: StandardizedUsage = {
        inputTokens: 0,
        outputTokens: 0
    };

    // Add logic per provider
    if (provider === 'gemini') {
        if (metadata) {
            usage.inputTokens = metadata.promptTokenCount || 0;
            usage.outputTokens = metadata.candidatesTokenCount || 0;
        }
    } 
    // else if (provider === 'openai') { ... }
    // else if (provider === 'anthropic') { ... }

    return usage;
} 

===== api/utils/timeUtils.ts =====
/**
 * Parses an ISO 8601 duration string (e.g., P1DT2H30M) into a human-readable format.
 * Handles basic PnYnMnDTnHnMnS formats. Does not handle weeks (PnW) or combined date/time components perfectly for large durations.
 *
 * @param durationString The ISO 8601 duration string.
 * @returns A human-readable string representation (e.g., "1 day 2 hours 30 minutes") or null if parsing fails or duration is zero.
 */
export function parseISODuration(durationString: string | null | undefined): string | null {
  if (!durationString) {
    return null;
  }

  // Regex to capture components of ISO 8601 duration PnYnMnDTnHnMnS
  // It handles optional components.
  const regex = /^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)D)?T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?$/;
  const matches = durationString.match(regex);

  if (!matches) {
    console.warn(`[parseISODuration] Could not parse duration string: ${durationString}`);
    // Optionally return the original string or handle specific common non-ISO formats if needed
    // For now, return null for unparseable formats.
    return null;
  }

  const parts = {
    years: parseInt(matches[1]) || 0,
    months: parseInt(matches[2]) || 0,
    days: parseInt(matches[3]) || 0,
    hours: parseInt(matches[4]) || 0,
    minutes: parseInt(matches[5]) || 0,
    seconds: parseFloat(matches[6]) || 0,
  };

  const readableParts: string[] = [];

  if (parts.years > 0) readableParts.push(`${parts.years} year${parts.years > 1 ? 's' : ''}`);
  if (parts.months > 0) readableParts.push(`${parts.months} month${parts.months > 1 ? 's' : ''}`);
  if (parts.days > 0) readableParts.push(`${parts.days} day${parts.days > 1 ? 's' : ''}`);
  if (parts.hours > 0) readableParts.push(`${parts.hours} hour${parts.hours > 1 ? 's' : ''}`);
  if (parts.minutes > 0) readableParts.push(`${parts.minutes} minute${parts.minutes > 1 ? 's' : ''}`);
  // Optionally include seconds if needed, or round them if fractional
  // if (parts.seconds > 0) readableParts.push(`${Math.round(parts.seconds)} second${parts.seconds !== 1 ? 's' : ''}`);

  if (readableParts.length === 0) {
      // Handle cases like PT0S or P0D etc.
      console.warn(`[parseISODuration] Duration string resulted in zero time: ${durationString}`);
      return null; 
  }

  return readableParts.join(' ');
} 

===== api/utils/preprocessText.ts =====
export function preprocessRawRecipeText(text: string): string {
  let processedText = text.trim();
  processedText = processedText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  processedText = processedText.replace(/\n{3,}/g, '\n\n');
  return processedText;
} 

===== api/utils/hash.ts =====
import { createHash } from 'crypto';

/**
 * Generates a SHA256 hash for the given input string.
 * Useful for creating consistent cache keys for raw text.
 * @param input The string to hash.
 * @returns A SHA256 hash string (hexadecimal).
 */
export function generateCacheKeyHash(input: string): string {
  return createHash('sha256').update(input).digest('hex');
} 

===== api/utils/__tests__/detectInputType.test.ts =====
import { detectInputType, InputType } from '../detectInputType';

describe('detectInputType', () => {
  // Test cases for URL detection
  it('should detect valid URLs with http/https prefix', () => {
    expect(detectInputType('http://example.com')).toBe<InputType>('url');
    expect(detectInputType('https://example.com')).toBe<InputType>('url');
    expect(detectInputType('https://www.example.com/path?query=value#fragment')).toBe<InputType>('url');
  });

  it('should detect valid URLs without http/https prefix but with domain pattern', () => {
    expect(detectInputType('example.com')).toBe<InputType>('url');
    expect(detectInputType('www.example.com')).toBe<InputType>('url');
    expect(detectInputType('example.co.uk/path')).toBe<InputType>('url');
    expect(detectInputType('sub.domain.example.com')).toBe<InputType>('url');
  });

  it('should detect URLs with few lines', () => {
    // TODO: Review detectInputType logic for multi-line URL-like strings.
    // Currently, internal newlines cause it to be treated as raw_text.
    expect(detectInputType('example.com\nsecond line')).toBe<InputType>('raw_text');
    expect(detectInputType('example.com\nsecond line\nthird line')).toBe<InputType>('raw_text');
  });

  // Test cases for raw text detection
  it('should detect raw text when no URL pattern is matched', () => {
    expect(detectInputType('This is a simple sentence.')).toBe<InputType>('raw_text');
    expect(detectInputType('Ingredients:\n1 cup flour\n2 eggs')).toBe<InputType>('raw_text');
  });

  it('should detect raw text for domain-like strings with too many lines', () => {
    expect(detectInputType('example.com\nsecond line\nthird line\nfourth line')).toBe<InputType>('raw_text');
  });

  it('should detect raw text for inputs that might look like URLs but are not', () => {
    expect(detectInputType('file.txt')).toBe<InputType>('url'); // This is an edge case, could be debated based on strictness
    expect(detectInputType('localhost:3000')).toBe<InputType>('raw_text'); // No TLD
    expect(detectInputType('not a url . com')).toBe<InputType>('raw_text'); // Contains spaces
  });

  it('should handle empty or whitespace-only strings as raw_text', () => {
    expect(detectInputType('')).toBe<InputType>('raw_text');
    expect(detectInputType('   ')).toBe<InputType>('raw_text');
  });

  // Test cases from original isProbablyUrl logic (if any specific examples are known)
  it('should correctly classify based on original isProbablyUrl logic', () => {
    // Example: "contains a period and no whitespace"
    expect(detectInputType('word.word')).toBe<InputType>('url');
    // Example: "contains a period but also whitespace"
    expect(detectInputType('word.word with space')).toBe<InputType>('raw_text');
    expect(detectInputType(' text with.period ')).toBe<InputType>('raw_text');
  });
}); 

===== api/utils/__tests__/preprocessText.test.ts =====
import { preprocessRawRecipeText } from '../preprocessText';

describe('preprocessRawRecipeText', () => {
  test('should trim leading and trailing whitespace', () => {
    const inputText = '  \n Recipe Text \t ';
    const expectedText = 'Recipe Text';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should normalize CRLF line breaks to LF', () => {
    const inputText = 'Line 1\r\nLine 2';
    const expectedText = 'Line 1\nLine 2';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should normalize CR line breaks to LF', () => {
    const inputText = 'Line 1\rLine 2';
    const expectedText = 'Line 1\nLine 2';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should keep existing LF line breaks', () => {
    const inputText = 'Line 1\nLine 2';
    const expectedText = 'Line 1\nLine 2';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should reduce 3 or more consecutive newlines to exactly 2', () => {
    const inputText = 'Line 1\n\n\nLine 2\n\n\n\n\nLine 3';
    const expectedText = 'Line 1\n\nLine 2\n\nLine 3';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should keep single and double newlines as they are', () => {
    const inputText = 'Line 1\nLine 2\n\nLine 3';
    const expectedText = 'Line 1\nLine 2\n\nLine 3';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should handle combined trimming, normalization, and blank line reduction', () => {
    const inputText = '  Start\r\n\n\n\nMiddle line\rEnd  \n ';
    const expectedText = 'Start\n\nMiddle line\nEnd';
    expect(preprocessRawRecipeText(inputText)).toBe(expectedText);
  });

  test('should return empty string for empty input', () => {
    expect(preprocessRawRecipeText('')).toBe('');
  });

  test('should return empty string for whitespace-only input', () => {
    expect(preprocessRawRecipeText('   \t\n  ')).toBe('');
  });
}); 

===== api/utils/__tests__/truncate.test.ts =====
import { truncateTextByLines } from '../truncate';

// Mock console.log before tests run
let consoleSpy: jest.SpyInstance;
beforeAll(() => {
  consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
});

// Restore console.log after tests finish
afterAll(() => {
  consoleSpy.mockRestore();
});

describe('truncateTextByLines', () => {
  const text = 'Line 1\nLine 2\nLine 3\nLine 4\nLine 5';

  test('should truncate text when lines exceed maxLines', () => {
    const maxLines = 3;
    const expected = 'Line 1\nLine 2\nLine 3\n\n[CONTENT TRUNCATED]';
    expect(truncateTextByLines(text, maxLines)).toBe(expected);
  });

  test('should not truncate text when lines are equal to maxLines', () => {
    const maxLines = 5;
    expect(truncateTextByLines(text, maxLines)).toBe(text);
  });

  test('should not truncate text when lines are less than maxLines', () => {
    const maxLines = 10;
    expect(truncateTextByLines(text, maxLines)).toBe(text);
  });

  test('should use custom marker when provided', () => {
    const maxLines = 2;
    const customMarker = '... [MORE] ...';
    const expected = `Line 1\nLine 2${customMarker}`;
    expect(truncateTextByLines(text, maxLines, customMarker)).toBe(expected);
  });

  test('should handle text with fewer lines than maxLines gracefully', () => {
    const shortText = 'Line A\nLine B';
    const maxLines = 5;
    expect(truncateTextByLines(shortText, maxLines)).toBe(shortText);
  });

  test('should return empty string for null input', () => {
    expect(truncateTextByLines(null, 5)).toBe('');
  });

  test('should return empty string for undefined input', () => {
    expect(truncateTextByLines(undefined, 5)).toBe('');
  });

  test('should return empty string for empty string input', () => {
    expect(truncateTextByLines('', 5)).toBe('');
  });

  test('should handle maxLines of 0 correctly', () => {
    const expected = '\n\n[CONTENT TRUNCATED]'; // Returns only the marker
    expect(truncateTextByLines(text, 0)).toBe(expected);
  });

  test('should handle text with trailing newlines correctly when truncating', () => {
    const textWithTrailing = 'Line 1\nLine 2\n\n';
    const maxLines = 1;
    const expected = 'Line 1\n\n[CONTENT TRUNCATED]';
    expect(truncateTextByLines(textWithTrailing, maxLines)).toBe(expected);
  });

   test('should handle text with trailing newlines correctly when not truncating', () => {
    const textWithTrailing = 'Line 1\nLine 2\n\n';
    const maxLines = 4;
    expect(truncateTextByLines(textWithTrailing, maxLines)).toBe(textWithTrailing);
  });
}); 

===== api/utils/__tests__/hash.test.ts =====
import { generateCacheKeyHash } from '../hash';
import { createHash } from 'crypto';

describe('generateCacheKeyHash', () => {
  test('should generate a consistent SHA256 hash for a given input', () => {
    const input = 'My test recipe text';
    const expectedHash = createHash('sha256').update(input).digest('hex'); // Calculate expected hash
    
    expect(generateCacheKeyHash(input)).toBe(expectedHash);
    // Verify it's consistent by calling again
    expect(generateCacheKeyHash(input)).toBe(expectedHash); 
  });

  test('should generate a different hash for different input', () => {
    const input1 = 'Recipe A';
    const input2 = 'Recipe B';
    expect(generateCacheKeyHash(input1)).not.toBe(generateCacheKeyHash(input2));
  });

  test('should generate a consistent hash for an empty string', () => {
    const input = '';
    const expectedHash = createHash('sha256').update(input).digest('hex');
    expect(generateCacheKeyHash(input)).toBe(expectedHash);
  });

  test('should generate a hash of the expected length (SHA256 hex = 64 chars)', () => {
    const input = 'Some random text';
    const hash = generateCacheKeyHash(input);
    expect(hash).toHaveLength(64);
    expect(/^[a-f0-9]{64}$/.test(hash)).toBe(true); // Check if it contains only hex characters
  });
}); 

===== api/utils/detectInputType.ts =====
export type InputType = 'url' | 'raw_text' | 'audio' | 'image' | 'video';

/**
 * Detects if the input string is likely a URL or raw text.
 * Based on the logic from the original isProbablyUrl function.
 * @param input The input string.
 * @returns 'url' if it looks like a URL, otherwise 'raw_text'.
 */
export function detectInputType(input: string): InputType {
  const trimmed = input.trim();

  // Check for explicit http(s) prefix
  const httpPattern = /^https?:\/\//i;
  if (httpPattern.test(trimmed)) {
    return 'url';
  }

  // Check for a general domain pattern and limit line count
  const domainPattern = /^[^\s\/$.?#].[^\s]*\.[a-zA-Z]{2,}(\/[\w.-]*)*\/?(\?[\w%.-]+=[\w%.-]+(&[\w%.-]+=[\w%.-]+)*)?(#\w*)?$/;
  if (domainPattern.test(trimmed)) {
    // Consider it a URL only if it also has few lines (original logic)
    if (input.split('\n').length <= 3) {
      return 'url';
    }
  }

  // Otherwise, assume it's raw text
  return 'raw_text';
} 

===== api/utils/truncate.ts =====
export function truncateTextByLines(text: string | null | undefined, maxLines: number, marker: string = "\n\n[CONTENT TRUNCATED]"): string {
  if (!text) {
    return '';
  }
  const lines = text.split('\n');
  if (lines.length > maxLines) {
    console.log(`Truncating text from ${lines.length} lines to ${maxLines} lines.`);
    return lines.slice(0, maxLines).join('\n') + marker;
  }
  return text;
} 

===== api/types.ts =====
// api/types.ts

// Remove incorrect import
// import { StructuredIngredient } from "./utils/recipeUtils"; 
import { GoogleGenerativeAI, GenerationConfig } from "@google/generative-ai";
import { StandardizedUsage } from "./utils/usageUtils";

// Structured Ingredient Type
export type StructuredIngredient = {
  name: string;
  amount: string | null;
  unit: string | null;
  suggested_substitutions?: SubstitutionSuggestion[] | null;
};

// Combined Parsed Recipe Type
export type CombinedParsedRecipe = {
  title: string | null;
  ingredients: StructuredIngredient[] | null;
  instructions: string[] | null;
  substitutions_text: string | null;
  recipeYield?: string | null;
  prepTime?: string | null;
  cookTime?: string | null;
  totalTime?: string | null;
  nutrition?: {
    calories?: string | null;
    protein?: string | null;
    [key: string]: any;
  } | null;
};

// Substitution Suggestion Type
export type SubstitutionSuggestion = {
  name: string;
  description?: string | null;
  amount?: string | number | null;
  unit?: string | null;
};

// Gemini Model Type
export type GeminiModel = ReturnType<InstanceType<typeof GoogleGenerativeAI>['getGenerativeModel']>;

// --- Shared Gemini Handler Response Type ---
export type GeminiHandlerResponse = {
    recipe: CombinedParsedRecipe | null;
    error: string | null;
    usage: StandardizedUsage;
    timings: { geminiCombinedParse: number; };
};


===== api/lib/supabase.ts =====
import { createClient } from '@supabase/supabase-js'
import { Database } from '../types/database.types'
import dotenv from 'dotenv'

dotenv.config()

const supabaseUrl = process.env.SUPABASE_URL!
const supabaseKey = process.env.SUPABASE_ANON_KEY!

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient<Database>(supabaseUrl, supabaseKey)


===== api/index.ts =====
import express from 'express'
import { recipeRouter } from './routes/recipes'
import { ingredientRouter } from './routes/ingredients'

const app = express()

app.use(express.json())

// Health check endpoint
app.get('/api/health', (_req, res) => {
  res.send('ðŸŸ¢ Backend is running')
})

app.use('/api/recipes', recipeRouter)
app.use('/api/ingredients', ingredientRouter)

export default app


===== api/routes/ingredients.ts =====
import { Router, Request, Response } from 'express'
import { supabase } from '../lib/supabase'

const router = Router()

// Update ingredient
router.patch('/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const updates = req.body
    
    const { data, error } = await supabase
      .from('ingredients')
      .update(updates)
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    res.json(data)
  } catch (error) {
    console.error('Error in PATCH /ingredients/:id :', error); 
    const message = error instanceof Error ? error.message : 'An unknown error occurred';
    res.status(500).json({ error: message });
  }
})

// Add substitution to ingredient
router.post('/:id/substitutions', async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const { name, description } = req.body
    
    const { data, error } = await supabase
      .from('substitutions')
      .insert({
        ingredient_id: id,
        name,
        description
      })
      .select()
      .single()
    
    if (error) throw error
    res.json(data)
  } catch (error) {
    console.error('Error in POST /ingredients/:id/substitutions :', error); 
    const message = error instanceof Error ? error.message : 'An unknown error occurred';
    res.status(500).json({ error: message });
  }
})

export const ingredientRouter = router


===== api/routes/recipes.ts =====
import { Router, Request, Response } from 'express'
import { supabase } from '../lib/supabase'
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold, GenerationConfig, Content } from "@google/generative-ai"; // Import Google AI SDK
import scraperapiClient from 'scraperapi-sdk';
import { parseAndCacheRecipe } from '../services/parseRecipe';
import { createRecipeWithIngredients } from '../services/recipeService';
import { rewriteForSubstitution } from '../services/substitutionRewriter';
import { scaleInstructions } from '../services/instructionScaling';

const router = Router()

// --- Initialize ScraperAPI Client ---
const scraperApiKey = process.env.SCRAPERAPI_KEY;
if (!scraperApiKey) {
  console.error('SCRAPERAPI_KEY environment variable is not set!');
}
const scraperClient = scraperapiClient(scraperApiKey || ''); 

// --- Initialize Google AI Client ---
const googleApiKey = process.env.GOOGLE_API_KEY;
if (!googleApiKey) {
  console.error('GOOGLE_API_KEY environment variable is not set!');
}
const genAI = new GoogleGenerativeAI(googleApiKey || '');
const geminiConfig: GenerationConfig = {
  responseMimeType: "application/json",
  temperature: 0.1, 
};
const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];
const geminiModel = genAI.getGenerativeModel({
    model: "gemini-1.5-flash-latest",
    generationConfig: geminiConfig,
    safetySettings: safetySettings,
});

// Get all recipes
router.get('/', async (req: Request, res: Response) => {
  try {
    const { data, error } = await supabase
      .from('recipes')
      .select(`
        *,
        ingredients (*)
      `)
    
    if (error) throw error
    res.json(data)
  } catch (error) {
    const message = error instanceof Error ? error.message : 'An unknown error occurred';
    res.status(500).json({ error: message });
  }
})

// Get single recipe with ingredients and substitutions
router.get('/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params
    const { data, error } = await supabase
      .from('recipes')
      .select(`
        *,
        ingredients (
          *,
          substitutions (*)
        )
      `)
      .eq('id', id)
      .single()
    
    if (error) throw error
    res.json(data)
  } catch (error) {
    const message = error instanceof Error ? error.message : 'An unknown error occurred';
    res.status(500).json({ error: message });
  }
})

// Create new custom user-created recipe, NOT in full parsing flow; not currently being used 
router.post('/', async (req: Request, res: Response) => {
  const { title, servings, ingredients } = req.body;

  const { result, error } = await createRecipeWithIngredients({ title, servings, ingredients });

  if (error) {
    return res.status(500).json({ error });
  }

  res.json(result);
});

// --- Main Parsing Route --- 
router.post('/parse', async (req: Request, res: Response) => {
  const { input } = req.body;
  if (!input || typeof input !== 'string' || input.trim() === '') {
    return res.status(400).json({ error: 'Missing or empty "input" in request body' });
  }

  if (!scraperApiKey) {
    return res.status(500).json({ error: 'Server configuration error: Missing ScraperAPI key.' });
  }

  const { recipe, error, fromCache, inputType, cacheKey, timings, usage, fetchMethodUsed } = await parseAndCacheRecipe(input, geminiModel, scraperApiKey, scraperClient);

  if (error) {
    console.error(`[API /parse Error] Failed to process input: ${input}`, error);
    return res.status(500).json({ error });
  }

  res.json({
    message: `Recipe processing complete (${inputType}).`,
    inputType,
    fromCache,
    cacheKey,
    timings,
    usage,
    fetchMethodUsed,
    recipe
  });
});

// --- Rewrite Instructions Endpoint ---
router.post('/rewrite-instructions', async (req: Request, res: Response) => {
  try {
    const { originalInstructions, originalIngredientName, substitutedIngredientName } = req.body;
    if (!originalInstructions || !Array.isArray(originalInstructions) || originalInstructions.length === 0) {
      return res.status(400).json({ error: 'Missing or invalid original instructions' });
    }
    if (!originalIngredientName || !substitutedIngredientName) {
      return res.status(400).json({ error: 'Missing original or substituted ingredient name' });
    }

    if (!googleApiKey) {
      return res.status(500).json({ error: 'Server configuration error: Missing Google API key.' });
    }

    const { rewrittenInstructions, error, usage, timeMs } = await rewriteForSubstitution(
      originalInstructions,
      originalIngredientName,
      substitutedIngredientName,
      geminiModel
    );

    if (error || !rewrittenInstructions) {
      console.error(`Failed to rewrite instructions with Gemini: ${error || 'Result was null'}`);
      return res.status(500).json({ error: `Failed to rewrite instructions: ${error || 'Unknown error'}` });
    } else {
      res.json({ rewrittenInstructions, usage, timeMs });
    }

  } catch (error) {
    console.error('Error in /rewrite-instructions route processing:', error);
    const message = error instanceof Error ? error.message : 'An unknown server error occurred';
    res.status(500).json({ error: message });
  }
});

// --- Scale Instructions Endpoint ---
router.post('/scale-instructions', async (req: Request, res: Response) => {
  try {
    const { instructionsToScale, originalIngredients, scaledIngredients } = req.body;
    if (!Array.isArray(instructionsToScale) || !Array.isArray(originalIngredients) || !Array.isArray(scaledIngredients)) {
      return res.status(400).json({ error: 'Invalid input: instructions, originalIngredients, and scaledIngredients must be arrays.' });
    }
    if (instructionsToScale.length === 0) {
      console.log("No instructions provided to scale.");
      return res.json({ scaledInstructions: [] });
    }
    if (originalIngredients.length !== scaledIngredients.length) {
      console.warn("Original and scaled ingredient lists have different lengths. Scaling might be inaccurate.");
    }

    if (!googleApiKey) {
      return res.status(500).json({ error: 'Server configuration error: Missing Google API key.' });
    }

    const { scaledInstructions, error, usage, timeMs } = await scaleInstructions(
      instructionsToScale,
      originalIngredients,
      scaledIngredients,
      geminiModel
    );

    if (error || !scaledInstructions) {
      console.error(`Failed to scale instructions with Gemini: ${error || 'Result was null'}`);
      return res.status(500).json({ error: `Failed to scale instructions: ${error || 'Unknown error'}` });
    } else {
      res.json({ scaledInstructions, usage, timeMs });
    }

  } catch (error) {
    console.error("Error in /scale-instructions route:", error);
    res.status(500).json({ error: 'Internal server error processing instruction scaling request.' });
  }
});

export const recipeRouter = router

===== api/routes/substitutions.ts =====


===== api/services/promptText.ts =====
import { CombinedParsedRecipe, GeminiModel, GeminiHandlerResponse } from '../types';
import { truncateTextByLines } from '../utils/truncate';
import { performance } from 'perf_hooks';
import { normalizeUsageMetadata, StandardizedUsage } from '../utils/usageUtils';

export async function parseRawTextWithGemini(
  preparedText: string,
  requestId: string,
  geminiModel: GeminiModel
): Promise<GeminiHandlerResponse> {
  const handlerStartTime = Date.now();
  console.log(`[${requestId}] Starting Gemini parsing for raw text input.`);

  let usage: StandardizedUsage = { inputTokens: 0, outputTokens: 0 };
  let recipe: CombinedParsedRecipe | null = null;
  let error: string | null = null;

  // Step 1: Truncate oversized text if needed
  const maxLength = 75000;
  const safeText = preparedText.length > maxLength
    ? truncateTextByLines(preparedText, 800, '\n\n[RAW TEXT TRUNCATED BY SYSTEM]')
    : preparedText;

  if (preparedText.length > maxLength) {
    console.warn(`[${requestId}] Raw text was truncated from ${preparedText.length} to ${safeText.length} characters.`);
  }

  // Step 2: Gemini Prompt
  const rawTextPrompt = `
You are an expert recipe parsing AI.

Your goal is to parse ALL structured information from the provided raw recipe text into a valid JSON object.

Expected JSON format:
{
  "title": "string | null",
  "ingredients": [
    {
      "name": "string",
      "amount": "string | null",
      "unit": "string | null",
      "suggested_substitutions": [
        {
          "name": "string",
          "amount": "string | number | null",
          "unit": "string | null",
          "description": "string | null"
        }
      ] | null
    }
  ] | null,
  "instructions": "array of strings, each a single step without numbering | null",
  "substitutions_text": "string | null",
  "recipeYield": "string | null",
  "prepTime": "string | null",
  "cookTime": "string | null",
  "totalTime": "string | null",
  "nutrition": {
    "calories": "string | null",
    "protein": "string | null"
  } | null
}

Parsing Rules:
- **VERY IMPORTANT**: If a value for a field (like prepTime, cookTime, totalTime, recipeYield, nutrition) is not explicitly found in the provided text, you MUST return \`null\` for that field in the JSON. DO NOT use \"N/A\", \"0\", or make up values. Be precise.
- Do not skip required keys â€” include them with null values if unknown.
- Exclude ingredients like "salt", "black pepper", "pepper", "sea salt".
- If steps mention ingredient subgroups, list the actual ingredients instead.
- Extract prepTime, cookTime, totalTime. Look for explicit mentions like "Prep Time: 15 min", "Cook: 45 minutes". Extract the value exactly as stated.
- Extract recipeYield. Look for terms like "Serves 4", "Yield: 12 cookies", "Makes 1 loaf". Extract the description (e.g., "4 servings", "12 cookies", "1 loaf").
- Extract nutrition info (calories, protein) if available (e.g., "350 kcal", "15g protein"). The entire nutrition object should be null if no nutrition info is found.
- Ingredient substitutions: Suggest 1-2 sensible culinary substitutions for each ingredient (except salt/pepper). Format as { name, amount, unit, description }. Return null for suggested_substitutions if none are found.
- Convert fractional ingredient amounts (e.g., "1 1/2") to decimals ("1.5").
- Output ONLY the JSON object. Do not include explanations, formatting, or extra text.

Raw Recipe Text:
${safeText}
`;

  console.log(`[${requestId}] Sending Gemini request (prompt length: ${rawTextPrompt.length}).`);
  const geminiStart = Date.now();

  try {
    if (rawTextPrompt.length > 150000) {
      throw new Error(`Prompt too large (${rawTextPrompt.length} chars).`);
    }

    const result = await geminiModel.generateContent(rawTextPrompt);
    const response = result.response;
    const text = response.text();

    usage = normalizeUsageMetadata(response.usageMetadata, 'gemini');

    const preview = text ? text.slice(0, 300) + (text.length > 300 ? '...' : '') : 'EMPTY';
    console.log(`[${requestId}] Gemini response preview:\n${preview}`);

    if (text) {
      try {
        recipe = JSON.parse(text);

        if (!recipe || typeof recipe !== 'object') throw new Error('Parsed JSON is not a valid object.');

        // Basic structure checks
        if (recipe.ingredients && !Array.isArray(recipe.ingredients)) {
          console.warn(`[${requestId}] ingredients not an array â€” nulling`);
          recipe.ingredients = null;
        }

        if (recipe.instructions && !Array.isArray(recipe.instructions)) {
          console.warn(`[${requestId}] instructions not an array â€” nulling`);
          recipe.instructions = null;
        }

        console.log(`[${requestId}] Successfully parsed Gemini output.`);
      } catch (parseErr: any) {
        console.error(`[${requestId}] JSON parse failed:`, parseErr);
        console.error(`[${requestId}] Raw response:\n${text}`);
        error = `Failed to parse Gemini response: ${parseErr.message}`;
      }
    } else {
      error = 'Empty response from Gemini.';
      console.warn(`[${requestId}] No text in Gemini response.`);
    }
  } catch (err: any) {
    console.error(`[${requestId}] Gemini call error:`, err);
    error = err instanceof Error ? err.message : 'Unknown Gemini error';

    if (err?.response?.promptFeedback?.blockReason) {
      error = `Gemini blocked response: ${err.response.promptFeedback.blockReason}`;
      console.error(`[${requestId}] Block reason: ${err.response.promptFeedback.blockReason}`);
      if (err.response.promptFeedback.safetyRatings) {
        console.error(`[${requestId}] Safety Ratings:`, JSON.stringify(err.response.promptFeedback.safetyRatings, null, 2));
      }
    }

    if (usage.inputTokens === 0 && usage.outputTokens === 0) {
      usage = normalizeUsageMetadata(null, 'gemini');
    }
  }

  const geminiParseTime = Date.now() - geminiStart;
  const totalTime = Date.now() - handlerStartTime;

  if (!recipe && !error) {
    console.warn(`[${requestId}] No result and no error â€” defaulting to unknown failure.`);
    error = 'AI returned no usable result.';
  }

  console.log(`[${requestId}] Gemini parsing complete. Time=${geminiParseTime}ms, Total=${totalTime}ms`);
  console.log(`[${requestId}] Token Usage: prompt=${usage.inputTokens}, output=${usage.outputTokens}`);

  return {
    recipe,
    error,
    usage,
    timings: { geminiCombinedParse: geminiParseTime }
  };
}

===== api/services/htmlFetch.ts =====
/**
 * Fetches HTML content from a URL, with fallback to ScraperAPI if direct fetch fails (e.g., 403).
 * 
 * @param url The URL to fetch.
 * @param scraperApiKey Your ScraperAPI key (optional, needed for fallback).
 * @param scraperClient An initialized ScraperAPI client instance.
 * @returns An object containing the HTML content, the fetch method used, and any error encountered.
 */
export async function fetchHtmlWithFallback(
  url: string, 
  scraperApiKey: string | undefined, 
  scraperClient: any // Consider defining a more specific type if possible from the SDK
): Promise<{ htmlContent: string; fetchMethodUsed: string; error: Error | null }> {
  let htmlContent = '';
  let fetchMethodUsed = 'Direct Fetch';
  let error: Error | null = null;
  const userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36';

  // Attempt 1: Direct Fetch
  console.log(`Attempting direct fetch from: ${url}`);
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': userAgent,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'Referer': 'https://www.google.com/',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'cross-site',
        'Sec-Fetch-User': '?1',
        'DNT': '1'
      }
    });
    if (!response.ok) {
      throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
    }
    htmlContent = await response.text();
    console.log(`Successfully fetched HTML via Direct Fetch. Length: ${htmlContent.length}`);
    console.log('[DEBUG htmlFetch] Raw HTML Content (Direct Fetch - first 500 chars):', htmlContent.substring(0, 500));
  } catch (directErr) {
    const directFetchError = directErr instanceof Error ? directErr : new Error(String(directErr));
    console.warn(`Direct fetch failed: ${directFetchError.message}`);
    error = directFetchError; // Assume error initially

    // Attempt 2: ScraperAPI Fallback
    if (scraperApiKey && scraperClient && (directFetchError.message.includes('Fetch failed: 403') || directFetchError)) {
      console.log(`Direct fetch failed. Falling back to ScraperAPI... Cause: ${directFetchError.message}`);
      
      // Determine if rendering is needed based on domain
      // const needsRender = url.includes('foodnetwork.com'); // Add other domains as needed // TEMP: Force false
      const needsRender = false; // TEMP: Force false to bypass render:true for testing
      const options = needsRender
        ? { render: true, autoparse: false, country_code: 'us' } 
        : { country_code: 'us' }; 
      const attemptType = needsRender ? 'ScraperAPI Rendered (autoparse=false)' : 'ScraperAPI Initial';
      fetchMethodUsed = attemptType;

      try {
          console.log(`[${attemptType}] ScraperAPI request options:`, JSON.stringify(options));
          console.log(`[${attemptType}] Fetching URL: ${url}`);
          const scraperResponse: any = await scraperClient.get(url, options); 

          // Determine HTML content based on response type
          let potentialHtml = '';
          let statusCode: number | undefined = undefined;
          if (typeof scraperResponse === 'object' && scraperResponse !== null) {
              if (typeof scraperResponse.body === 'string') {
                  potentialHtml = scraperResponse.body;
              }
              if (typeof scraperResponse.statusCode === 'number') {
                  statusCode = scraperResponse.statusCode;
              }
          } else if (typeof scraperResponse === 'string') {
              potentialHtml = scraperResponse;
          }

          // Validate the response
          const isValidHtml = potentialHtml && potentialHtml.toLowerCase().includes('<html');
          const isSuccessStatusCode = !statusCode || (statusCode >= 200 && statusCode < 300);

          if (isSuccessStatusCode && isValidHtml) {
              htmlContent = potentialHtml;
              console.log(`[${attemptType}] Successfully fetched valid HTML. Length: ${htmlContent.length}`);
              console.log(`[DEBUG htmlFetch] Raw HTML Content (${attemptType} - first 500 chars):`, htmlContent.substring(0, 500));
              error = null; // Clear original direct fetch error as fallback succeeded
          } else {
              // Construct error message for the failed attempt
              let failureReason = `returned ${statusCode || 'unknown status'}`;
              if (!isValidHtml) failureReason += ", and HTML content was invalid or missing <html> tag";
              throw new Error(`[${attemptType}] fallback failed: ${failureReason}`);
          }
      } catch (err) {
          const scraperError = err instanceof Error ? err : new Error(String(err));
          console.error(`[${attemptType}] Error:`, scraperError.message);
          // If the ScraperAPI attempt fails, construct the final combined error message
          error = new Error(`Direct fetch failed (${directFetchError.message}) and ScraperAPI fallback failed (${scraperError.message})`);
      }

    } else if (!scraperApiKey && directFetchError) {
         console.warn('Direct fetch failed and ScraperAPI key is missing. Cannot fallback.');
         // error is already set to directFetchError
    } else if (!scraperClient && directFetchError && scraperApiKey) {
        console.warn('Direct fetch failed and ScraperAPI client was not provided. Cannot fallback.');
        // error is already set to directFetchError
    }
  }
  return { htmlContent, fetchMethodUsed, error };
} 

===== api/services/substitutionRewriter.ts =====
import { performance } from 'perf_hooks';
import { formatMeasurement } from '../../utils/format';

type LLMResponse<T> = {
  [K in keyof T]: T[K];
} & {
  error: string | null;
  usage: { promptTokens: number; outputTokens: number } | null;
  timeMs: number | null;
};

export async function rewriteForSubstitution(originalInstructions: string[], originalIngredientName: string, substitutedIngredientName: string, geminiModel: any): Promise<LLMResponse<{ rewrittenInstructions: string[] | null }>> {
    const cleanedSubstitutedIngredientName = formatMeasurement(Number(substitutedIngredientName));

    const rewritePrompt = `
    You are an expert cooking assistant. You will rewrite cooking instructions to reflect ingredient substitutions based on user preferences.
    
    Original Ingredient: "${originalIngredientName}"
    Substituted Ingredient: "${cleanedSubstitutedIngredientName}"
    
    Consider:
    - Preparation differences (e.g. tofu may need pressing, beans may need soaking)
    - Cooking time or method changes based on the substituted ingredient
    - Flavor or texture impacts
    - Any changes in food safety or allergen concerns
    
    If no meaningful change is required, return the original steps unchanged.
    
    Respond with ONLY a valid JSON object:
    {
      "rewrittenInstructions": [ ... ] // each step as a plain string, without numbering
    }
    
    Original Instructions:
    ${originalInstructions.map(s => `- ${s}`).join('\n')}
`;

    const startTime = performance.now();

    try {
        if (rewritePrompt.length > 100000) {
            throw new Error(`Rewrite prompt too large (${rewritePrompt.length} chars).`);
        }

        const result = await geminiModel.generateContent(rewritePrompt);
        const response = result.response;
        const responseText = response.text();

        const endTime = performance.now();
        const timeMs = endTime - startTime;

        if (responseText) {
            try {
                const parsedResult: any = JSON.parse(responseText);
                if (typeof parsedResult === 'object' && parsedResult !== null && Array.isArray(parsedResult.rewrittenInstructions)) {
                    const usage = {
                        promptTokens: response.usageMetadata?.promptTokenCount || 0,
                        outputTokens: response.usageMetadata?.candidatesTokenCount || 0
                    };
                    return {
                        rewrittenInstructions: parsedResult.rewrittenInstructions.filter((step: any) => typeof step === 'string'),
                        error: null,
                        usage,
                        timeMs
                    };
                } else {
                    throw new Error("Parsed JSON result did not have the expected structure.");
                }
            } catch (parseError) {
                console.error('Raw content that failed parsing:', responseText);
                throw parseError;
            }
        } else {
            return { rewrittenInstructions: null, error: 'Empty response received from AI instruction rewriter.', usage: null, timeMs: null };
        }
    } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown Gemini rewrite error';
        return { rewrittenInstructions: null, error: errorMessage, usage: null, timeMs: null };
    }
} 

===== api/services/extractContent.ts =====
import * as cheerio from 'cheerio';

// Type definitions that might be shared or imported if structure grows
export type ExtractedContent = {
  title: string | null;
  ingredientsText: string | null;
  instructionsText: string | null;
  recipeYieldText?: string | null;
  isFallback?: boolean;
  prepTime?: string | null;
  cookTime?: string | null;
  totalTime?: string | null;
};

/**
 * Extracts recipe content (title, ingredients, instructions) from HTML.
 * Tries JSON-LD first, then falls back to common CSS selectors.
 * @param html The HTML content string.
 * @returns An object containing extracted title, ingredients text, and instructions text.
 */
export function extractRecipeContent(html: string): ExtractedContent {
  let $ = cheerio.load(html); // Load initial HTML

  // Initialize extracted fields
  let title: string | null = null;
  let ingredientsText: string | null = null;
  let instructionsText: string | null = null;
  let recipeYieldText: string | null = null;
  let isFallback = false;
  let prepTime: string | null = null;
  let cookTime: string | null = null;
  let totalTime: string | null = null;

  // Tier 1: Try JSON-LD
  let recipeJson: any = null;
  let ldJsonBlocksScanned = 0; // For logging
  let recipeFoundInLdJson = false; // For logging

  $('script[type="application/ld+json"]').each((_, element) => {
    // if (recipeJson) return; // REMOVED: We want to scan all and pick the first valid Recipe
    ldJsonBlocksScanned++;
    try {
      const scriptContent = $(element).html();
      if (!scriptContent) {
          return; 
      }
      
      console.log(`Found potential JSON-LD script content (first 2000 chars):\n${scriptContent.slice(0, 2000)}`);

      const jsonData = JSON.parse(scriptContent);
      let candidate = null;

      if (Array.isArray(jsonData)) {
        candidate = jsonData.find(item => item && item['@type'] === 'Recipe');
      } else if (jsonData && jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
        candidate = jsonData['@graph'].find((item: any) => item && item['@type'] === 'Recipe');
      } else if (jsonData && jsonData['@type'] === 'Recipe') {
        candidate = jsonData;
      }

      if (candidate && !recipeJson) { // If a recipe candidate is found and we haven't stored one yet
        recipeJson = candidate;
        recipeFoundInLdJson = true; // Mark that we found and are using a recipe from JSON-LD
        // Do not return here; continue scanning in case a more complete Recipe object is found later?
        // For now, per the suggestion, we take the first valid one.
      }

    } catch (e) {
      console.warn("Ignoring JSON-LD parsing error:", e);
    }
  });

  console.log(`[JSON-LD Scan] Scanned ${ldJsonBlocksScanned} ld+json blocks. Recipe type found and used: ${recipeFoundInLdJson}.`); // Logging

  if (recipeJson) { // This condition now means a valid Recipe object was found and assigned
    console.log("Found and using recipe data from JSON-LD."); // Updated log message
    title = recipeJson.name || null;
    // Ingredients can be string[]
    if (Array.isArray(recipeJson.recipeIngredient)) {
       ingredientsText = recipeJson.recipeIngredient.join('\n');
    }
    // Instructions can be string, string[], or array of HowToStep objects
    if (typeof recipeJson.recipeInstructions === 'string') {
        instructionsText = recipeJson.recipeInstructions;
    } else if (Array.isArray(recipeJson.recipeInstructions)) {
        // Check if it's an array of strings or HowToStep objects
        if (recipeJson.recipeInstructions.every((item: any) => typeof item === 'string')) {
            instructionsText = recipeJson.recipeInstructions.join('\n');
        } else if (recipeJson.recipeInstructions.every((item: any) => typeof item === 'object' && item.text)) {
            // Array of HowToStep objects (common format)
            instructionsText = recipeJson.recipeInstructions.map((step: any) => step.text).join('\n');
        } else if (recipeJson.recipeInstructions.every((item: any) => typeof item === 'object' && item['@type'] === 'HowToSection')) {
             // Handle sections containing steps
             instructionsText = recipeJson.recipeInstructions
                .flatMap((section: any) => section.itemListElement || [])
                .map((step: any) => step.text)
                .join('\n');
        }
    }
    // Extract recipeYield from JSON-LD if available
    if (recipeJson.recipeYield) {
      if (Array.isArray(recipeJson.recipeYield)) {
        // Handle cases where yield might be an array (e.g., "6 servings", "makes 12 cookies")
        // We'll take the first one or try to make sense of it.
        // For simplicity, join if it's an array of strings, or take first if complex.
        recipeYieldText = recipeJson.recipeYield.join(', '); // Or more sophisticated joining
      } else {
        recipeYieldText = String(recipeJson.recipeYield);
      }
    }

    // --- Extract Time Fields from JSON-LD --- 
    prepTime = recipeJson.prepTime || null;
    cookTime = recipeJson.cookTime || null;
    totalTime = recipeJson.totalTime || null;
    // --- End Time Field Extraction --- 

    // Fallback title extraction if needed, only if JSON-LD didn't yield one
    if (!title) title = $('title').first().text() || $('h1').first().text() || null;

    console.log(`Extracted from JSON-LD - Title: ${!!title}, Ingredients: ${!!ingredientsText}, Instructions: ${!!instructionsText}, Yield: ${!!recipeYieldText}, Prep: ${!!prepTime}, Cook: ${!!cookTime}, Total: ${!!totalTime}`);
    // If JSON-LD provides the essentials (ingredients AND instructions), return it (including times)
    if (ingredientsText && instructionsText) {
        return { title, ingredientsText, instructionsText, recipeYieldText, isFallback, prepTime, cookTime, totalTime };
    }
    // Continue to selector fallback if JSON-LD was incomplete for essentials
  }

  // --- Pre-stripping & Content Isolation (MOVED HERE) ---
  // This runs if JSON-LD was not found or was incomplete for essentials.
  console.log("JSON-LD not found or incomplete for essentials. Applying pre-stripping and attempting main content isolation before selector fallback.");
  
  // Create a new Cheerio instance from the original HTML for pre-stripping,
  // as the original '$' might have been modified if mainContentHtml was previously loaded.
  // However, we should operate on the version of '$' that reflects the current state.
  // If mainContentHtml was *already* isolated due to a previous iteration (which shouldn't happen with this new flow),
  // we'd want to use that. But since JSON-LD failed, we re-evaluate from potentially broader HTML.
  // The initial '$' is still the full HTML at this point if JSON-LD parsing didn't result in an early return.

  // Remove common non-content tags from the *current* Cheerio instance
  $('script, style, iframe, noscript, footer, nav').remove();
  // Remove common cookie/consent/modal elements
  $('[id*="consent" i], [class*="consent" i], [id*="cookie" i], [class*="cookie" i], [class*="banner" i], [role="dialog" i], [aria-modal="true" i]').remove();

  // Attempt to isolate the main content area from the *current* Cheerio instance
  const mainSelectors = [
      'article[id*="recipe" i]',
      'div[id*="recipe" i]',
      'div[class*="recipe-content" i]',
      'div[class*="wprm-recipe-container" i]', // Common recipe plugin class
      'main[id*="main" i]',
      'main',
      'article'
  ];
  let mainContentHtml: string | null = null;
  for (const selector of mainSelectors) {
      const mainElement = $(selector).first();
      if (mainElement.length > 0) {
          const potentialHtml = mainElement.html();
          if (potentialHtml && potentialHtml.length > 500) {
              console.log(`Found potential main content container using selector: ${selector}. Reloading Cheerio with this content.`);
              mainContentHtml = potentialHtml;
              break;
          }
      }
  }

  if (mainContentHtml) {
      $ = cheerio.load(mainContentHtml); // Reload Cheerio with only the main content for subsequent selector parsing
  } else {
      console.log("Could not isolate a specific main content container after JSON-LD attempt, proceeding with pre-stripped body for selectors.");
  }
  // --- End Pre-stripping & Isolation ---

  // Tier 2: Fallback to Selectors (or run if JSON-LD was incomplete)
  // Note: The console log for this was moved up to the start of the pre-stripping block.
  if (!title) { // Title might have been parsed by JSON-LD even if other fields were missing
    const titleFromSelectors = $('title').first().text() || $('h1').first().text() || null;
    if (titleFromSelectors) title = titleFromSelectors;
  }

  // Ingredient Selectors
  if (!ingredientsText) {
      const ingredientSelectors = [
        '[itemprop="recipeIngredient"]',
        '.wprm-recipe-ingredient', 
        '.tasty-recipes-ingredients li', 
        '.easyrecipe-ingredient',
        '.recipe-ingredients li',
        '.ingredients li',
        '.ingredient-list li'
      ];
      const collectedIngredients = new Set<string>();
      for (const selector of ingredientSelectors) {
          $(selector).each((_, el) => {
              const text = $(el).text().trim();
              if (text) collectedIngredients.add(text);
          });
      }
      if (collectedIngredients.size > 0) {
          ingredientsText = Array.from(collectedIngredients).join('\n');
      }
  }

  // Instruction Selectors
  if (!instructionsText) {
      const tempInstructionsSet = new Set<string>();
      const itemLevelSelectors = [
          '.wprm-recipe-instructions li', '.wprm-recipe-instructions p',
          '.tasty-recipes-instructions li', '.tasty-recipes-instructions p',
          '.easyrecipe-instructions li', '.easyrecipe-instructions p',
          '.recipe-instructions li', '.recipe-instructions p',
          '.instructions li', '.instructions p',
          '.direction-list li', '.direction-list p',
          '[itemprop="recipeInstructions"] li', '[itemprop="recipeInstructions"] p',
          '[itemprop="recipeInstructions"]'
      ];
      const blockLevelSelectors = [
          '.wprm-recipe-instructions',
          '.tasty-recipes-instructions',
          '.easyrecipe-instructions-content',
          '.recipe-instructions',
          '.instructions',
          '.directions'
      ];

      for (const selector of itemLevelSelectors) {
          $(selector).each((_, el) => {
              const text = $(el).text().trim();
              const isLikelyContainer = $(el).children().length > 0 && !$(el).is('li, p');
              if (text && !isLikelyContainer) {
                tempInstructionsSet.add(text);
              } else if (text && isLikelyContainer) {
                const lines = text.split(/\r\n|\n|\r/).map(line => line.trim()).filter(line => line);
                lines.forEach(line => tempInstructionsSet.add(line));
              }
          });
      }

      if (tempInstructionsSet.size === 0) {
          for (const selector of blockLevelSelectors) {
              const elements = $(selector);
              if (elements.length > 0) {
                   elements.each((_, el) => {
                       const blockText = $(el).text().trim();
                       if (blockText) {
                           const lines = blockText.split(/\r\n|\n|\r/).map(line => line.trim()).filter(line => line);
                           lines.forEach(line => tempInstructionsSet.add(line));
                       }
                   });
                   if (tempInstructionsSet.size > 0) break;
              }
          }
      }
      if (tempInstructionsSet.size > 0) {
          instructionsText = Array.from(tempInstructionsSet).join('\n');
      }
  }

  // Yield Selectors (new section)
  if (!recipeYieldText) { // Only run if JSON-LD didn't provide it
    const yieldSelectors = [
      '.wprm-recipe-servings', '.wprm-recipe-yield',
      '.tasty-recipes-yield', '.tasty-recipes-details .recipe-yield',
      '.easyrecipe-servings', '.mf-recipe-servings',
      '[itemprop="recipeYield"]', '[data-mv-recipe-meta="servings"] .mv-value',
      // Generic selectors looking for keywords if specific classes fail
      'div:contains("Servings:")', 'span:contains("Servings:")', 'p:contains("Servings:")',
      'div:contains("Yield:")', 'span:contains("Yield:")', 'p:contains("Yield:")',
      'div:contains("Makes:")', 'span:contains("Makes:")', 'p:contains("Makes:")'
    ];
    let foundYield = false;
    for (const selector of yieldSelectors) {
      if (foundYield) break;
      // For keyword selectors, we need more careful extraction
      if (selector.includes(':contains')) {
        const keyword = selector.substring(selector.indexOf('"') + 1, selector.lastIndexOf('"'));
        const tagName = selector.substring(0, selector.indexOf(':'));
        $(tagName).each((_, el) => {
          const elementText = $(el).text();
          if (elementText.toLowerCase().includes(keyword.toLowerCase())) {
            // Try to get the most specific text containing the keyword and its value
            // This is a simple approach; might need refinement
            const lines = elementText.split('\n').map(line => line.trim()).filter(line => line.toLowerCase().includes(keyword.toLowerCase()));
            if (lines.length > 0) {
              recipeYieldText = lines[0]; // Take the first line that contains the keyword
              foundYield = true;
              return false; // Break from .each()
            }
          }
        });
      } else {
        // For class/attribute selectors
        $(selector).each((_, el) => {
          const text = $(el).text().trim();
          if (text) {
            recipeYieldText = text;
            foundYield = true;
            return false; // Break from .each()
          }
        });
      }
    }
    if (recipeYieldText) {
      console.log(`Extracted recipeYieldText using selectors: ${recipeYieldText}`);
    }
  }

  // --- Fallback Logic (New Implementation) ---
  // Fallback: use raw body text if no structured content was found or content is too short.
  const minLengthThreshold = 50;
  const ingredientsMissingOrShort = !ingredientsText || ingredientsText.length < minLengthThreshold;
  const instructionsMissingOrShort = !instructionsText || instructionsText.length < minLengthThreshold;

  if (ingredientsMissingOrShort || instructionsMissingOrShort) {
    console.warn(`[extractContent] Fallback: using raw body text due to missing or short (${minLengthThreshold} chars) ingredients and/or instructions.`);
    // Refined cleaning: Collapse multiple spaces, collapse multiple newlines, then trim.
    const rawBodyText = $('body').text()
      .replace(/ +/g, ' ')        // Collapse multiple spaces to one
      .replace(/\n\s*\n/g, '\n')  // Collapse multiple newlines (optional whitespace between) to one
      .trim();
    isFallback = true; // Set the flag when fallback occurs

    // Only overwrite if the original extraction was insufficient
    if (ingredientsMissingOrShort) {
      ingredientsText = rawBodyText;
    }
    if (instructionsMissingOrShort) {
      instructionsText = rawBodyText;
    }
  }

  console.log(`Final Extracted Content - Title: ${!!title}, Ingredients: ${!!ingredientsText}, Instructions: ${!!instructionsText}, Yield: ${!!recipeYieldText}, Prep: ${!!prepTime}, Cook: ${!!cookTime}, Total: ${!!totalTime}, Fallback Used: ${isFallback}`);
  // Return structure includes the fallback flag again
  return { title, ingredientsText, instructionsText, recipeYieldText, isFallback, prepTime, cookTime, totalTime };
}


===== api/services/urlProcessor.ts =====
import { fetchHtmlWithFallback } from './htmlFetch';
import { extractRecipeContent, ExtractedContent } from './extractContent'; // Import ExtractedContent type

type FetchExtractTimings = {
  fetchHtml: number;
  extractContent: number;
};

type FetchExtractResult = {
  extractedContent: ExtractedContent | null;
  error: string | null;
  fetchMethodUsed: string;
  timings: FetchExtractTimings;
};

/**
 * Fetches HTML from a URL (with fallback) and extracts recipe content.
 * @param url The recipe URL.
 * @param requestId A unique identifier for logging.
 * @param scraperApiKey The ScraperAPI key (optional).
 * @param scraperClient The ScraperAPI client instance.
 * @returns An object containing extracted content, fetch method, timings, and error status.
 */
export async function fetchAndExtractFromUrl(
  url: string,
  requestId: string,
  scraperApiKey: string | undefined,
  scraperClient: any
): Promise<FetchExtractResult> {
  const handlerStartTime = Date.now(); // Keep track of total time within this specific function if needed, though parseAndCacheRecipe does overall timing.
  console.log(`[${requestId}] Starting URL fetch & extract for: ${url}`);
  let timings: FetchExtractTimings = { fetchHtml: -1, extractContent: -1 };
  let fetchMethodUsed = 'Direct Fetch';
  let processingError: string | null = null;
  let extractedContent: ExtractedContent | null = null;

  // Step 1: Fetch HTML
  const fetchStartTime = Date.now();
  const fetchResult = await fetchHtmlWithFallback(url, scraperApiKey, scraperClient);
  let htmlContent = fetchResult.htmlContent;
  let fetchError = fetchResult.error;
  fetchMethodUsed = fetchResult.fetchMethodUsed;
  timings.fetchHtml = Date.now() - fetchStartTime;

  if (fetchError) {
      console.error(`[${requestId}] Fetch process failed for URL ${url}: ${fetchError.message}`);
      processingError = `Failed to retrieve recipe content from ${url}: ${fetchError.message}`;
  } else if (htmlContent.length === 0) {
      const finalErrorMessage = 'HTML content was empty after fetch attempts';
      console.error(`[${requestId}] Fetch process failed for URL ${url}: ${finalErrorMessage}`);
      processingError = `Failed to retrieve recipe content from ${url}: ${finalErrorMessage}`;
  }

  if (processingError) {
    // Return early if fetch failed
    return { extractedContent: null, error: processingError, fetchMethodUsed, timings };
  }

  console.log(`[${requestId}] Using HTML content obtained via: ${fetchMethodUsed} (URL: ${url}, Length: ${htmlContent.length})`);

  // Step 2: Extract Content
  console.log(`[${requestId}] Pre-processing HTML with cheerio for URL: ${url}...`);
  const extractStartTime = Date.now();
  try {
      extractedContent = extractRecipeContent(htmlContent);
      timings.extractContent = Date.now() - extractStartTime;

      // --- ADDED DEBUG LOG ---
      if (extractedContent) {
        console.log('[DEBUG urlProcessor] Extracted ingredientsText (first 500 chars):', extractedContent.ingredientsText ? extractedContent.ingredientsText.substring(0, 500) : 'null/empty');
        console.log('[DEBUG urlProcessor] Extracted instructionsText (first 500 chars):', extractedContent.instructionsText ? extractedContent.instructionsText.substring(0, 500) : 'null/empty');
      } else {
        console.log('[DEBUG urlProcessor] extractedContent is null after extractRecipeContent');
      }
      // --- END DEBUG LOG ---

      if (!extractedContent.ingredientsText || !extractedContent.instructionsText) {
          console.warn(`[${requestId}] Failed to extract clear ingredients or instructions using cheerio for URL: ${url}. Proceeding with partial data.`);
      } else {
          console.log(`[${requestId}] Successfully extracted content sections for URL: ${url}.`);
      }
  } catch (extractErr: any) {
      console.error(`[${requestId}] Error during content extraction for URL ${url}:`, extractErr);
      timings.extractContent = Date.now() - extractStartTime;
      processingError = `Failed to extract content from HTML for ${url}: ${extractErr.message}`;
      extractedContent = null; // Ensure content is null if extraction fails
  }

  console.log(`[${requestId}] Fetch & Extract finished for ${url}. Fetch=${timings.fetchHtml}ms, Extract=${timings.extractContent}ms`);

  return { extractedContent, error: processingError, fetchMethodUsed, timings };
}

// Need to import the ExtractedContent type from extractContent.ts
// Make sure extractContent.ts exports it. 

===== api/services/recipeService.ts =====
import { supabase } from '../lib/supabase';

export async function createRecipeWithIngredients({ title, servings, ingredients }: { title: string; servings: number; ingredients: any[] }): Promise<{ result: any; error: string | null }> {
    try {
        const { data: recipe, error: recipeError } = await supabase
            .from('recipes')
            .insert({ title, servings })
            .select()
            .single();

        if (recipeError) throw recipeError;

        if (ingredients && ingredients.length > 0) {
            const ingredientsWithRecipeId = ingredients.map((ing: any) => ({
                ...ing,
                recipe_id: recipe.id
            }));

            const { error: ingredientsError } = await supabase
                .from('ingredients')
                .insert(ingredientsWithRecipeId);

            if (ingredientsError) throw ingredientsError;
        }

        return { result: recipe, error: null };
    } catch (error) {
        const message = error instanceof Error ? error.message : 'An unknown error occurred';
        return { result: null, error: message };
    }
} 

===== api/services/__tests__/htmlFetch.test.ts =====
import { fetchHtmlWithFallback } from '../htmlFetch';

// Mock the global fetch function
global.fetch = jest.fn();

// Create a mock ScraperAPI client
const mockScraperClient = {
  get: jest.fn(),
};

// Define default mock API key
const mockApiKey = 'test-scraper-api-key';

// Store original console methods
const originalConsoleLog = console.log;
const originalConsoleWarn = console.warn;
const originalConsoleError = console.error;

describe('fetchHtmlWithFallback', () => {
  beforeEach(() => {
    // Reset mocks before each test
    (global.fetch as jest.Mock).mockClear();
    mockScraperClient.get.mockClear();
    // Suppress console output during tests
    console.log = jest.fn();
    console.warn = jest.fn();
    console.error = jest.fn();
  });

  afterEach(() => {
    // Restore console output after each test
    console.log = originalConsoleLog;
    console.warn = originalConsoleWarn;
    console.error = originalConsoleError;
  });

  test('should return HTML from direct fetch on success', async () => {
    const mockHtml = '<html><body>Direct Success</body></html>';
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      text: async () => mockHtml,
    });

    const result = await fetchHtmlWithFallback('http://example.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe(mockHtml);
    expect(result.fetchMethodUsed).toBe('Direct Fetch');
    expect(result.error).toBeNull();
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).not.toHaveBeenCalled();
  });

  test('should use ScraperAPI fallback if direct fetch returns 403', async () => {
    const fallbackHtml = '<html><body>Fallback Success</body></html>';
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: false,
      status: 403,
      statusText: 'Forbidden',
    });
    mockScraperClient.get.mockResolvedValueOnce({ body: fallbackHtml }); // Simulate SDK response structure

    const result = await fetchHtmlWithFallback('http://blocked.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe(fallbackHtml);
    expect(result.fetchMethodUsed).toBe('ScraperAPI Initial');
    expect(result.error).toBeNull();
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).toHaveBeenCalledWith('http://blocked.com', { country_code: 'us' });
  });
  
   test('should use ScraperAPI fallback if direct fetch returns non-403 error and API key exists', async () => {
    const fallbackHtml = '<html><body>Fallback Success After 500</body></html>';
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });
    mockScraperClient.get.mockResolvedValueOnce({ body: fallbackHtml });

    const result = await fetchHtmlWithFallback('http://servererror.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe(fallbackHtml);
    expect(result.fetchMethodUsed).toBe('ScraperAPI Initial');
    expect(result.error).toBeNull();
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).toHaveBeenCalledTimes(1);
  });

  test('should use ScraperAPI fallback if direct fetch throws network error and API key exists', async () => {
    const fallbackHtml = '<html><body>Fallback Success After Network Error</body></html>';
    const networkError = new Error('Network request failed');
    (global.fetch as jest.Mock).mockRejectedValueOnce(networkError);
    mockScraperClient.get.mockResolvedValueOnce({ body: fallbackHtml });

    const result = await fetchHtmlWithFallback('http://networkerror.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe(fallbackHtml);
    expect(result.fetchMethodUsed).toBe('ScraperAPI Initial');
    expect(result.error).toBeNull(); 
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).toHaveBeenCalledTimes(1);
  });

  test('should return error if direct fetch fails and ScraperAPI fallback also fails', async () => {
    const directError = new Error('Fetch failed: 403 Forbidden');
    (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 403,
        statusText: 'Forbidden'
    });
    const fallbackError = new Error('Scraper API failed');
    mockScraperClient.get.mockRejectedValueOnce(fallbackError);

    const result = await fetchHtmlWithFallback('http://bothfail.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe('');
    expect(result.fetchMethodUsed).toBe('ScraperAPI Initial');
    expect(result.error).toBeInstanceOf(Error);
    expect(result.error?.message).toContain('Fetch failed: 403 Forbidden');
    expect(result.error?.message).toContain('Scraper API failed');
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).toHaveBeenCalledTimes(1);
  });

  test('should return direct fetch error if API key is missing and direct fetch fails', async () => {
     const directError = new Error('Fetch failed: 403 Forbidden');
     (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 403,
        statusText: 'Forbidden'
    });

    // Pass undefined for apiKey
    const result = await fetchHtmlWithFallback('http://directfailnokey.com', undefined, mockScraperClient);

    expect(result.htmlContent).toBe('');
    expect(result.fetchMethodUsed).toBe('Direct Fetch');
    expect(result.error).toEqual(directError);
    expect(global.fetch).toHaveBeenCalledTimes(1);
    expect(mockScraperClient.get).not.toHaveBeenCalled();
  });

  test('should handle scraper returning plain string successfully', async () => {
    const fallbackHtmlString = '<html><body>Fallback String Success</body></html>';
    (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Direct fetch failed'));
    mockScraperClient.get.mockResolvedValueOnce(fallbackHtmlString); // Simulate direct string response

    const result = await fetchHtmlWithFallback('http://fallbackstring.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe(fallbackHtmlString);
    expect(result.fetchMethodUsed).toBe('ScraperAPI Initial');
    expect(result.error).toBeNull();
    expect(mockScraperClient.get).toHaveBeenCalledTimes(1);
  });

   test('should return error if ScraperAPI returns unexpected response format', async () => {
    (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Direct fetch failed'));
    // Simulate unexpected response (not string, not object with .body)
    mockScraperClient.get.mockResolvedValueOnce({ someOtherKey: 'value' }); 

    const result = await fetchHtmlWithFallback('http://badfallbackformat.com', mockApiKey, mockScraperClient);

    expect(result.htmlContent).toBe('');
    expect(result.fetchMethodUsed).toBe('ScraperAPI Initial');
    expect(result.error).toBeInstanceOf(Error);
    expect(result.error?.message).toContain('[ScraperAPI Initial] fallback failed: returned unknown status, and HTML content was invalid or missing <html> tag');
    expect(mockScraperClient.get).toHaveBeenCalledTimes(1);
  });

}); 

===== api/services/__tests__/extractContent.test.ts =====
import { extractRecipeContent, ExtractedContent } from '../extractContent';

describe('extractRecipeContent', () => {

  // Test Case 1: Valid JSON-LD
  test('should extract content correctly from valid JSON-LD', () => {
    const htmlWithJsonLd = `
      <html>
        <head>
          <title>Fallback Title</title>
          <script type="application/ld+json">
            {
              "@context": "https://schema.org/",
              "@type": "Recipe",
              "name": "JSON-LD Recipe Title",
              "recipeIngredient": [
                "1 cup Flour",
                "2 Eggs"
              ],
              "recipeInstructions": [
                {
                  "@type": "HowToStep",
                  "text": "Mix ingredients."
                },
                {
                  "@type": "HowToStep",
                  "text": "Bake the cake."
                }
              ],
              "recipeYield": "4 servings",
              "prepTime": "PT15M",
              "cookTime": "PT30M",
              "totalTime": "PT45M"
            }
          </script>
        </head>
        <body>
          <h1>HTML Title</h1>
          <div class="ingredients">
            <ul><li>HTML Ingredient</li></ul>
          </div>
           <div class="instructions">
            <ol><li>HTML Instruction</li></ol>
          </div>
        </body>
      </html>
    `;
    const expected: ExtractedContent = {
      title: 'JSON-LD Recipe Title',
      ingredientsText: '1 cup Flour\n2 Eggs',
      instructionsText: 'Mix ingredients.\nBake the cake.',
      recipeYieldText: '4 servings',
      prepTime: 'PT15M',
      cookTime: 'PT30M',
      totalTime: 'PT45M',
      isFallback: false
    };
    expect(extractRecipeContent(htmlWithJsonLd)).toEqual(expected);
  });

  // Test Case 2: JSON-LD in @graph
  test('should extract content correctly from JSON-LD within @graph', () => {
    const htmlWithGraphJsonLd = `
      <html>
        <head><title>Graph Test</title></head>
        <body>
          <script type="application/ld+json">
            {
              "@context": "https://schema.org/",
              "@graph": [
                {
                  "@type": "WebSite",
                  "name": "Website Name"
                },
                {
                  "@type": "Recipe",
                  "name": "Graph Recipe Title",
                  "recipeIngredient": ["Ingredient A", "Ingredient B"],
                  "recipeInstructions": "Single instruction step."
                }
              ]
            }
          </script>
        </body>
      </html>
    `;
    const expected: ExtractedContent = {
      title: 'Graph Recipe Title',
      ingredientsText: 'Ingredient A\nIngredient B',
      instructionsText: 'Single instruction step.',
      recipeYieldText: null,
      prepTime: null,
      cookTime: null,
      totalTime: null,
      isFallback: false
    };
    expect(extractRecipeContent(htmlWithGraphJsonLd)).toEqual(expected);
  });

  // Test Case 3: Fallback to CSS Selectors (No JSON-LD)
  test('should extract content using CSS selectors when JSON-LD is missing', () => {
    const htmlWithoutJsonLd = `
      <html>
        <head><title>CSS Selector Title</title></head>
        <body>
          <h1>Another H1 Title</h1>
          <ul class="ingredients">
            <li>Ingredient 1</li>
            <li itemprop="recipeIngredient">Ingredient 2</li>
          </ul>
          <div class="wprm-recipe-instructions">
            <p>Step 1.</p>
            <li>Step 2.</li>
          </div>
        </body>
      </html>
    `;
    const expectedFallbackText = "Another H1 Title\n Ingredient 1\n Ingredient 2\n Step 1.\n Step 2.";
    const result = extractRecipeContent(htmlWithoutJsonLd);

    expect(result.title).toEqual('CSS Selector Title');
    expect(result.ingredientsText).toEqual(expectedFallbackText);
    expect(result.instructionsText).toEqual(expectedFallbackText);
    expect(result.recipeYieldText).toBeNull();
    expect(result.prepTime).toBeNull();
    expect(result.cookTime).toBeNull();
    expect(result.totalTime).toBeNull();
    expect(result.isFallback).toBe(true);
  });

  // Test Case 4: Incomplete JSON-LD (e.g., missing instructions), fallback for missing parts
  test('should fallback to CSS selectors for parts missing in JSON-LD and handle short content fallback', () => {
    const htmlIncompleteJsonLd = `
      <html>
        <head>
          <title>Fallback Title</title>
          <script type="application/ld+json">
            {
              "@context": "https://schema.org/",
              "@type": "Recipe",
              "name": "Incomplete JSON Recipe",
              "recipeIngredient": ["JSON Ingredient 1"]
            }
          </script>
        </head>
        <body>
          <ol class="instructions">
             <li>Selector Instruction 1</li>
             <li>Selector Instruction 2</li>
          </ol>
        </body>
      </html>
    `;
    const expectedFallbackText = "Selector Instruction 1\n Selector Instruction 2";
    const expected: ExtractedContent = {
      title: 'Incomplete JSON Recipe',
      ingredientsText: expectedFallbackText,
      instructionsText: expectedFallbackText,
      recipeYieldText: null,
      prepTime: null,
      cookTime: null,
      totalTime: null,
      isFallback: true
    };
    expect(extractRecipeContent(htmlIncompleteJsonLd)).toEqual(expected);
  });

  // Test Case 5: No Recipe Content Found
  test('should return fallback body text when no recipe content is found via JSON-LD or selectors', () => {
    const htmlNoRecipe = `
      <html>
        <head><title>Just a Page</title></head>
        <body>
          <p>This page has no recipe information.</p>
        </body>
      </html>
    `;
    const expectedFallbackText = "This page has no recipe information.";
    const expected: ExtractedContent = {
      title: 'Just a Page', // Title from <title>
      ingredientsText: expectedFallbackText,
      instructionsText: expectedFallbackText,
      recipeYieldText: null,
      prepTime: null,
      cookTime: null,
      totalTime: null,
      isFallback: true
    };
    expect(extractRecipeContent(htmlNoRecipe)).toEqual(expected);
  });

  // Test Case 6: Different common selector patterns
  test('should extract content using alternative common CSS selectors and handle short content fallback', () => {
    const htmlAlternativeSelectors = `
      <html>
        <head><title>Alt Selector Recipe</title></head>
        <body>
          <div class="tasty-recipes-ingredients">
             <ul><li>Tasty Ingredient A</li></ul>
          </div>
          <ol class="easyrecipe-instructions">
            <li>Easy Instruction 1</li>
          </ol>
        </body>
      </html>
    `;
    const expectedFallbackText = "Tasty Ingredient A\n Easy Instruction 1";
    const expected: ExtractedContent = {
      title: 'Alt Selector Recipe',
      ingredientsText: expectedFallbackText,
      instructionsText: expectedFallbackText,
      recipeYieldText: null,
      prepTime: null,
      cookTime: null,
      totalTime: null,
      isFallback: true
    };
    expect(extractRecipeContent(htmlAlternativeSelectors)).toEqual(expected);
  });

  // Test Case 7: Instructions as HowToSection in JSON-LD
  test('should extract instructions from HowToSection in JSON-LD', () => {
      const htmlWithHowToSection = `
      <html>
        <head>
          <title>HowToSection Test</title>
          <script type="application/ld+json">
            {
              "@context": "https://schema.org/",
              "@type": "Recipe",
              "name": "HowToSection Recipe Title",
              "recipeIngredient": ["Ingredient X", "Ingredient Y"],
              "recipeInstructions": [
                {
                  "@type": "HowToSection",
                  "name": "Make the dough",
                  "itemListElement": [
                    {"@type": "HowToStep", "text": "Combine flour and water."},
                    {"@type": "HowToStep", "text": "Knead the dough."}
                  ]
                },
                 {
                  "@type": "HowToSection",
                  "name": "Bake",
                  "itemListElement": [
                    {"@type": "HowToStep", "text": "Place in oven."},
                    {"@type": "HowToStep", "text": "Bake for 30 minutes."}
                  ]
                }
              ]
            }
          </script>
        </head>
        <body></body>
      </html>
    `;
      const expected: ExtractedContent = {
          title: 'HowToSection Recipe Title',
          ingredientsText: 'Ingredient X\nIngredient Y',
          instructionsText: 'Combine flour and water.\nKnead the dough.\nPlace in oven.\nBake for 30 minutes.',
          recipeYieldText: null,
          prepTime: null,
          cookTime: null,
          totalTime: null,
          isFallback: false
      };
      expect(extractRecipeContent(htmlWithHowToSection)).toEqual(expected);
  });

  // Test Case 8: Malformed JSON-LD, fallback to CSS selectors, then to body
  test('should ignore malformed JSON-LD and fallback to CSS selectors, then to body if short', () => {
    const htmlWithMalformedJsonLd = `
      <html>
        <head>
          <title>CSS Fallback Title</title>
          <script type="application/ld+json">
            {
              "@context": "https://schema.org/",
              "@type": "Recipe",
              "name": "Malformed JSON Recipe Title",
              "recipeIngredient": ["JSON Ing 1", "JSON Ing 2"], // Trailing comma here is an error
            }
          </script>
        </head>
        <body>
          <h1 class="recipe-title">Selector Title After Malformed JSON</h1>
          <ul class="ingredients">
            <li>Selector Ingredient A</li>
            <li>Selector Ingredient B</li>
          </ul>
          <div class="instructions">
            <p>Selector Instruction 1</p>
            <p>Selector Instruction 2</p>
          </div>
        </body>
      </html>
    `;

    const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});
    const result = extractRecipeContent(htmlWithMalformedJsonLd);
    
    expect(consoleWarnSpy).toHaveBeenCalledWith(
      "Ignoring JSON-LD parsing error:", 
      expect.any(SyntaxError)
    );
    expect(consoleWarnSpy).toHaveBeenCalledWith(
      expect.stringContaining('[extractContent] Fallback: using raw body text due to missing or short (50 chars) ingredients and/or instructions.')
    );

    const expectedFallbackText = "Selector Title After Malformed JSON\n Selector Ingredient A\n Selector Ingredient B\n Selector Instruction 1\n Selector Instruction 2";
    
    expect(result.title).toEqual('CSS Fallback Title');
    expect(result.ingredientsText).toEqual(expectedFallbackText);
    expect(result.instructionsText).toEqual(expectedFallbackText);
    expect(result.recipeYieldText).toBeNull();
    expect(result.prepTime).toBeNull();
    expect(result.cookTime).toBeNull();
    expect(result.totalTime).toBeNull();
    expect(result.isFallback).toBe(true);

    consoleWarnSpy.mockRestore();
  });

}); 

===== api/services/parseRecipe.ts =====
import { GeminiModel, CombinedParsedRecipe, GeminiHandlerResponse } from '../types';
import { supabase } from '../lib/supabase';
import { createHash } from 'crypto';
import { detectInputType, InputType } from '../utils/detectInputType';
import { generateCacheKeyHash } from '../utils/hash';
import { fetchAndExtractFromUrl } from './urlProcessor';
import { extractFromRawText } from './textProcessor';
import { parseUrlContentWithGemini } from './promptUrl';
import { parseRawTextWithGemini } from './promptText';
import scraperapiClient from 'scraperapi-sdk';
import { StandardizedUsage } from '../utils/usageUtils';

// Define a maximum length for output previews
const MAX_PREVIEW_LENGTH = 100;

export type ParseResult = {
    recipe: CombinedParsedRecipe | null;
    error: string | null;
    fromCache: boolean;
    inputType: InputType;
    cacheKey: string;
    timings: {
        dbCheck: number;
        fetchHtml?: number;
        extractContent?: number;
        prepareText?: number;
        geminiParse: number;
        dbInsert: number;
        total: number;
    };
    usage: StandardizedUsage;
    fetchMethodUsed?: string;
};

export async function parseAndCacheRecipe(
    input: string,
    geminiModel: GeminiModel,
    scraperApiKey: string,
    scraperClient: any
): Promise<ParseResult> {
    const requestId = createHash('sha256').update(Date.now().toString() + Math.random().toString()).digest('hex').substring(0, 12);
    const requestStartTime = Date.now();
    let overallTimings: ParseResult['timings'] = {
        dbCheck: -1,
        geminiParse: -1,
        dbInsert: -1,
        total: -1
    };
    let handlerUsage: StandardizedUsage = { inputTokens: 0, outputTokens: 0 };
    let fetchMethodUsed: string | undefined = 'N/A';

    if (!input || typeof input !== 'string' || input.trim() === '') {
        console.warn(`[${requestId}] Invalid request: Missing or empty "input" in request body.`);
        return { recipe: null, error: 'Missing or empty "input" in request body', fromCache: false, inputType: 'raw_text', cacheKey: '', timings: overallTimings, usage: { inputTokens: 0, outputTokens: 0 }, fetchMethodUsed: 'N/A' };
    }

    const trimmedInput = input.trim();
    const inputType = detectInputType(input);

    // --- BEGIN EARLY INPUT TYPE VALIDATION ---
    const SUPPORTED_INPUT_TYPES: ReadonlyArray<InputType> = ['url', 'raw_text'];
    if (!SUPPORTED_INPUT_TYPES.includes(inputType)) {
        const errorMsg = `Unsupported input type detected: ${inputType}`;
        console.error(`[${requestId}] ${errorMsg}`);
        overallTimings.total = Date.now() - requestStartTime; // Capture total time before early exit
        return {
            recipe: null,
            error: errorMsg,
            fromCache: false,
            inputType: inputType, // Report the problematic type
            cacheKey: generateCacheKeyHash(trimmedInput), // Generate a cache key even for unsupported types for consistency if needed, or could be empty
            timings: overallTimings,
            usage: { inputTokens: 0, outputTokens: 0 },
            fetchMethodUsed: 'N/A'
        };
    }
    // --- END EARLY INPUT TYPE VALIDATION ---

    const cacheKey = inputType === 'url' ? trimmedInput : generateCacheKeyHash(trimmedInput);

    console.log(`[${requestId}] Received parse request. Input type: ${inputType}. Input length: ${trimmedInput.length}. Cache key: ${cacheKey}`);

    const dbCheckStartTime = Date.now();
    try {
        const { data: cachedRecipe, error: dbError } = await supabase
            .from('processed_recipes_cache')
            .select('recipe_data')
            .eq('url', cacheKey)
            .maybeSingle();

        overallTimings.dbCheck = Date.now() - dbCheckStartTime;

        if (dbError) {
            console.error(`[${requestId}] Error checking cache in Supabase for key ${cacheKey}:`, dbError);
        }

        if (cachedRecipe && cachedRecipe.recipe_data) {
            console.log(`[${requestId}] Cache hit for key: ${cacheKey}. Returning cached data. DB Check time: ${overallTimings.dbCheck}ms.`);
            overallTimings.total = Date.now() - requestStartTime;
            return { recipe: cachedRecipe.recipe_data, error: null, fromCache: true, inputType, cacheKey, timings: overallTimings, usage: handlerUsage, fetchMethodUsed: 'N/A' };
        }
        console.log(`[${requestId}] Cache miss for key: ${cacheKey}. DB Check time: ${overallTimings.dbCheck}ms. Proceeding with processing.`);
    } catch (cacheError) {
        overallTimings.dbCheck = Date.now() - dbCheckStartTime;
        console.error(`[${requestId}] Exception during cache check for key ${cacheKey}:`, cacheError);
    }

    let processingError: string | null = null;
    let finalRecipeData: CombinedParsedRecipe | null = null;
    let geminiResponse: GeminiHandlerResponse | null = null;

    if (inputType === 'url') {
        const { extractedContent, error: fetchExtractError, fetchMethodUsed: fmUsed, timings: feTimings } = await fetchAndExtractFromUrl(trimmedInput, requestId, scraperApiKey, scraperClient);
        fetchMethodUsed = fmUsed;
        overallTimings.fetchHtml = feTimings.fetchHtml;
        overallTimings.extractContent = feTimings.extractContent;

        if (fetchExtractError || !extractedContent) {
            processingError = fetchExtractError || 'Failed to fetch or extract content from URL.';
            console.error(`[${requestId}] URL processing failed during fetch/extract: ${processingError}`);
        } else {
            const totalLength = (extractedContent?.ingredientsText?.length ?? 0) + (extractedContent?.instructionsText?.length ?? 0);
            console.log(`[${requestId}] URL content prepared. Fetch/Extract time: ${overallTimings.fetchHtml + overallTimings.extractContent}ms. Method: ${fetchMethodUsed}. Combined text length (ingredients+instructions): ${totalLength}`);
            geminiResponse = await parseUrlContentWithGemini(extractedContent, requestId, geminiModel);
            if (geminiResponse) {
                if (geminiResponse.error) {
                    processingError = geminiResponse.error;
                    console.error(`[${requestId}] URL processing failed during Gemini parse: ${processingError}`);
                } else {
                    finalRecipeData = geminiResponse.recipe;
                }
                overallTimings.geminiParse = geminiResponse.timings.geminiCombinedParse;
                handlerUsage = geminiResponse.usage;
                console.log(`[${requestId}] Gemini parse completed for URL. Time: ${overallTimings.geminiParse}ms. Tokens: In=${handlerUsage.inputTokens}, Out=${handlerUsage.outputTokens}.`);
            } else {
                processingError = 'Gemini response was unexpectedly null for URL.';
                console.error(`[${requestId}] ${processingError}`);
                overallTimings.geminiParse = 0;
                handlerUsage = { inputTokens: 0, outputTokens: 0 };
            }
        }
    } else if (inputType === 'raw_text') {
        const { preparedText, error: prepareError, timings: prepTimings } = extractFromRawText(trimmedInput, requestId);
        overallTimings.prepareText = prepTimings.prepareText;

        if (prepareError) {
            processingError = prepareError;
            console.error(`[${requestId}] Raw text processing failed during preparation: ${processingError}`);
        } else {
            console.log(`[${requestId}] Raw text prepared. Preparation time: ${overallTimings.prepareText}ms. Prepared text length: ${preparedText?.length ?? 0}`);
            geminiResponse = await parseRawTextWithGemini(preparedText, requestId, geminiModel);
            if (geminiResponse) {
                if (geminiResponse.error) {
                    processingError = geminiResponse.error;
                    console.error(`[${requestId}] Raw text processing failed during Gemini parse: ${processingError}`);
                } else {
                    finalRecipeData = geminiResponse.recipe;
                }
                overallTimings.geminiParse = geminiResponse.timings.geminiCombinedParse;
                handlerUsage = geminiResponse.usage;
                console.log(`[${requestId}] Gemini parse completed for Raw Text. Time: ${overallTimings.geminiParse}ms. Tokens: In=${handlerUsage.inputTokens}, Out=${handlerUsage.outputTokens}.`);
            } else {
                processingError = 'Gemini response was unexpectedly null for Raw Text.';
                console.error(`[${requestId}] ${processingError}`);
                overallTimings.geminiParse = 0;
                handlerUsage = { inputTokens: 0, outputTokens: 0 };
            }
        }
    }

    if (processingError) {
        overallTimings.total = Date.now() - requestStartTime;
        console.error(`[${requestId}] Processing ultimately failed for input. Error: ${processingError}. Input Type: ${inputType}. Final Timings: ${JSON.stringify(overallTimings)}`);
        return { recipe: null, error: processingError, fromCache: false, inputType, cacheKey, timings: overallTimings, usage: handlerUsage, fetchMethodUsed };
    }

    if (finalRecipeData) {
        const preview = finalRecipeData.title
            ? finalRecipeData.title.substring(0, MAX_PREVIEW_LENGTH) + (finalRecipeData.title.length > MAX_PREVIEW_LENGTH ? '...' : '')
            : '(No title found)';
        console.log(`[${requestId}] Successfully parsed recipe. Preview (Title): "${preview}"`);

        const dbInsertStartTime = Date.now();
        try {
            const { error: insertError } = await supabase
                .from('processed_recipes_cache')
                .insert({
                    url: cacheKey,
                    recipe_data: finalRecipeData,
                    source_type: inputType
                });

            overallTimings.dbInsert = Date.now() - dbInsertStartTime;

            if (insertError) {
                console.error(`[${requestId}] Error saving recipe to cache (key: ${cacheKey}):`, insertError);
            } else {
                console.log(`[${requestId}] Successfully cached new recipe (key: ${cacheKey}). DB Insert time: ${overallTimings.dbInsert}ms`);
            }
        } catch (cacheInsertError) {
            overallTimings.dbInsert = Date.now() - dbInsertStartTime;
            console.error(`[${requestId}] Exception during cache insertion (key: ${cacheKey}):`, cacheInsertError);
        }
    } else {
        console.warn(`[${requestId}] Processing finished without error, but no final recipe data was produced. Input Type: ${inputType}.`);
        overallTimings.dbInsert = 0;
    }

    overallTimings.total = Date.now() - requestStartTime;
    console.log(`[${requestId}] Request complete. Success: ${!!finalRecipeData}. Input Type: ${inputType}. From Cache: false. Fetch Method: ${fetchMethodUsed}. Final Timings (ms): ${JSON.stringify(overallTimings)}`);
    console.log(`[${requestId}] Final Token Usage: Input=${handlerUsage.inputTokens}, Output=${handlerUsage.outputTokens}`);

    return {
        recipe: finalRecipeData,
        error: null,
        fromCache: false,
        inputType,
        cacheKey,
        timings: overallTimings,
        usage: handlerUsage,
        fetchMethodUsed
    };
} 

===== api/services/promptUrl.ts =====
import { GoogleGenerativeAI } from "@google/generative-ai";
import { truncateTextByLines } from '../utils/truncate';
import { CombinedParsedRecipe, GeminiModel, GeminiHandlerResponse } from '../types';
import { ExtractedContent } from './extractContent'; // Need this type
import { normalizeUsageMetadata, StandardizedUsage } from '../utils/usageUtils'; // Import the new utility
import { parseISODuration } from '../utils/timeUtils'; // Import the utility

// --- New function for Gemini Parsing of URL content ---
export async function parseUrlContentWithGemini(
    extractedContent: ExtractedContent,
    requestId: string,
    geminiModel: GeminiModel
): Promise<GeminiHandlerResponse> {
    const handlerStartTime = Date.now(); // For timing this specific step
    console.log(`[${requestId}] Starting Gemini parsing for extracted URL content.`);
    let usage: StandardizedUsage = { inputTokens: 0, outputTokens: 0 };
    let combinedParsedResult: CombinedParsedRecipe | null = null;
    let processingError: string | null = null;

    // Define truncation limits
    const fallbackMaxChars = 100000; // Max CHARACTERS if using raw body fallback
    const defaultMaxIngredientLines = 40;
    const defaultMaxInstructionLines = 40;

    let textToParse = ``;
    let promptPrefix = ``;

    if (extractedContent.isFallback) {
        console.log(`[${requestId}] Fallback extraction detected. Preparing raw body text for prompt (max ${fallbackMaxChars} chars).`);
        // Use the simpler prompt prefix for direct raw text
        promptPrefix = `This is raw page text from a cooking website. Please extract structured data:
- Title
- Ingredients (as list)
- Instructions (as clear steps)
`;
        
        const cleanedRawBody = extractedContent.ingredientsText 
            ? extractedContent.ingredientsText.split('\n').map(line => line.trim()).filter(line => line).join('\n') 
            : '';
        
        // --- Log sample of cleanedRawBody --- 
        if (cleanedRawBody) {
            console.log(`[${requestId}] Sample of cleaned raw body text (first 50 lines):
${cleanedRawBody.split('\n').slice(0, 50).join('\n')}`);
        }
        // --- End Log --- 

        let safeRawBodyText = cleanedRawBody;
        if (safeRawBodyText.length > fallbackMaxChars) {
            console.warn(`[${requestId}] Fallback raw body text exceeds ${fallbackMaxChars} chars (${safeRawBodyText.length}). Truncating by characters.`);
            safeRawBodyText = safeRawBodyText.substring(0, fallbackMaxChars) + "\n\n[RAW BODY TEXT TRUNCATED BY SYSTEM (CHAR LIMIT)]";
        } else {
            console.log(`[${requestId}] Fallback raw body text within char limit (${safeRawBodyText.length} chars).`);
        }

        // --- Skip Heuristic Filtering (Temporary) --- 
        console.log(`[${requestId}] Skipping heuristic filtering. Using character-truncated raw body text directly.`);
        const formattedRawText = `
------------------------
${safeRawBodyText}
------------------------`;
        // --- End Skip --- 
        
        textToParse = `**Provided Text Sections:**\n\nTitle:\n${extractedContent.title || 'N/A'}\n\nExplicit Recipe Yield Text:\n${extractedContent.recipeYieldText || 'N/A'}\n\nRaw Page Content:\n${formattedRawText || 'N/A'}`; // Use the formatted *unfiltered* raw text

    } else {
        console.log(`[${requestId}] Standard extraction detected. Using default truncation limits (Ingredients: ${defaultMaxIngredientLines}, Instructions: ${defaultMaxInstructionLines}).`);
        promptPrefix = `This is structured text from a recipe site with extracted ingredients and instructions.`;

        const cleanedIngredients = extractedContent.ingredientsText
            ? extractedContent.ingredientsText.split('\n').map(line => line.trim()).filter(line => line).join('\n')
            : null;
        const safeIngredientsText = truncateTextByLines(cleanedIngredients, defaultMaxIngredientLines, "\n\n[INGREDIENTS TRUNCATED BY SYSTEM]");
        
        const safeInstructionsText = truncateTextByLines(extractedContent.instructionsText, defaultMaxInstructionLines, "\n\n[INSTRUCTIONS TRUNCATED BY SYSTEM]");
        
        textToParse = `**Provided Text Sections:**\n\nTitle:\n${extractedContent.title || 'N/A'}\n\nExplicit Recipe Yield Text:\n${extractedContent.recipeYieldText || 'N/A'}\n\nIngredients Text:\n${safeIngredientsText || 'N/A'}\n\nInstructions Text:\n${safeInstructionsText || 'N/A'}`;
    }

    // Gemini Prompt - Combined with updated prefix logic
    const combinedPromptForUrl = `${promptPrefix}

Your goal is to parse ALL information from the provided text sections into a single, specific JSON object.

**Important Note:** If processing 'Raw Page Content' (due to fallback), use the provided raw text. If processing separate 'Ingredients Text' and 'Instructions Text', use those specific sections.

**Desired JSON Structure:**
{ 
  "title": "string | null", 
  "ingredients": [
    { 
      "name": "string", 
      "amount": "string | null", 
      "unit": "string | null", 
      "suggested_substitutions": [
        { 
          "name": "string", 
          "amount": "string | number | null", 
          "unit": "string | null", 
          "description": "string | null" 
        }
      ] | null 
    }
  ] | null, 
  "instructions": "array of strings, each a single step without numbering | null", 
  "substitutions_text": "string | null", 
  "recipeYield": "string | null", // Examples: "6 servings", "12 cookies", "Makes one 9-inch pie"
  "prepTime": "string | null",     // Examples: "15 minutes", "20 min", "Approx. 10 mins"
  "cookTime": "string | null",     // Examples: "1 hour", "45 min", "90 minutes"
  "totalTime": "string | null",    // Examples: "1 hr 15 min", "About 1 hour"
  "nutrition": { 
    "calories": "string | null", // Example: "350 kcal", "400 calories per serving"
    "protein": "string | null"  // Example: "15g protein", "20 grams protein"
  } | null 
}

**Parsing Rules:**
1.  **Sections:** Parse the data from the 'Provided Text Sections' below. 
    - If 'Raw Page Content' is provided, attempt to find title, ingredients, instructions, etc., within it.
    - If separate 'Ingredients Text' and 'Instructions Text' are provided, use them primarily.
    - If a section (title, ingredients, instructions) cannot be found or is empty (appears as 'N/A' or is blank), use null for its value in the JSON. If text is present but seems nonsensical, too short, or clearly not a recipe, also consider using null for those arrays.
2.  **Instructions Array:** 
    - ONLY include actionable cooking/preparation steps. Split the provided instructions text into logical step-by-step actions. EXCLUDE serving suggestions, anecdotes, tips, etc. Ensure steps do not have numbering.
    - **Clarity for Sub-groups:** If an instruction refers to combining a sub-group of ingredients (e.g., 'dressing ingredients', 'tahini ranch ingredients'), and those ingredients are part of the main ingredient list you parsed, rephrase the instruction to explicitly list those specific ingredients. For example, instead of 'combine tahini ranch ingredients', if tahini, chives, and parsley are the ranch ingredients, the instruction should be 'combine tahini, dried chives, and dried parsley, whisking in water to thin...'.
3.  **Ingredients Array:** 
    - Parse the provided ingredients text into the structured array shown above.
    - **Convert Fractions:** Convert all fractional amounts (e.g., "1 1/2", "3/4") to their decimal representation (e.g., "1.5", "0.75") for the main ingredient's "amount".
    - **Handle Variations:** Handle ranges or optional parts. Use null if a part (amount, unit) isn't clearly identifiable.
    - **Quantity Handling:** If an ingredient clearly lacks a quantity (e.g., 'fresh cilantro'), set main "amount" to null and main "unit" to "to taste" or "as needed".
    - **Exclusions:** Do NOT include ingredients that are variations of 'sea salt', 'salt', 'black pepper', or 'pepper' in the final array.
4.  **Ingredient Substitutions:**
    - For each parsed ingredient (except salt/pepper), suggest 1-2 sensible culinary substitutions.
    - Each substitution suggestion MUST be an object with "name" (string), "amount" (string/number/null - the *equivalent* amount), "unit" (string/null), and optional "description" (string/null).
    - Base substitution amount/unit on volume/weight where possible, adjust for flavor/texture.
    - If no good substitutions come to mind, use null for "suggested_substitutions".
5.  **Substitutions Text:** Attempt to find any *explicit substitution notes* mentioned within the original INSTRUCTIONS text and place them in the top-level "substitutions_text" field, otherwise use null.
6.  **Metadata:** 
    - **VERY IMPORTANT:** If a value for a field (like prepTime, cookTime, totalTime, recipeYield, nutrition) is not explicitly found in the provided text, you MUST return \`null\` for that field in the JSON. DO NOT use "N/A", "0", or make up values. Be precise.
    - **recipeYield:** Your primary source for recipe yield (servings) should be the "Explicit Recipe Yield Text" provided below. This text is specifically extracted from fields likely to contain only the yield. Parse the yield description from this text (e.g., "Servings: 6" becomes "6 servings"; "Makes 2 dozen cookies" becomes "2 dozen cookies"; "Yield: 1 loaf" becomes "1 loaf"). If this explicit text is missing, empty, or clearly not a yield, then secondarily look for terms like "serves", "makes", "yields", "servings" in the main "Instructions Text" or "Ingredients Text", and extract the description. If no yield is found, use null.
    - **Time Fields (prepTime, cookTime, totalTime):** Look for explicit mentions like "Prep Time: 15 min", "Cook: 45 minutes", "Total Time: 1 hr". Extract the value exactly as stated (e.g., "15 min", "45 minutes", "1 hr"). Return null if not found.
    - **Nutrition:** Look for nutrition information, specifically "calories" and "protein". Extract the values if present (e.g., "350 kcal", "15g protein"). The entire "nutrition" object should be null if neither calories nor protein is found. If one is found but not the other, return the found value and null for the missing one within the nutrition object.
7.  **Output:** Ensure the output is ONLY the single, strictly valid JSON object described. Do not include explanations, markdown formatting, or any text outside the JSON structure.

${textToParse}
`;

    // --- ADDED DEBUG LOG ---
    console.log(`[DEBUG promptUrl] Gemini Prompt for ${requestId} (first 1000 chars):
${combinedPromptForUrl.substring(0, 1000)}`);
    // For full prompt, uncomment and be careful with large outputs:
    // console.log(`[DEBUG promptUrl] Full Gemini Prompt for ${requestId}:\n${combinedPromptForUrl}`); 
    // --- END DEBUG LOG ---

    console.log(`[${requestId}] Sending combined parsing request to Gemini for extracted URL content (prompt length: ${combinedPromptForUrl.length})`);
    const geminiCombinedStartTime = Date.now();


    try {
        if (combinedPromptForUrl.length > 150000) { // Keep safety check
            throw new Error(`URL Combined prompt is too large (${combinedPromptForUrl.length} chars).`);
        }
        const result = await geminiModel.generateContent(combinedPromptForUrl);
        const response = result.response;
        const responseText = response.text();


        usage = normalizeUsageMetadata(response.usageMetadata, 'gemini');


        const previewText = responseText ? (responseText.length > 300 ? responseText.substring(0, 300) + "..." : responseText) : "EMPTY";
        console.log(`[${requestId}] Gemini (URL Parse) raw JSON response preview: ${previewText}`);


        if (responseText) {
            try {
                combinedParsedResult = JSON.parse(responseText) as CombinedParsedRecipe;
                // Basic validation (copied from old handler)
                if (typeof combinedParsedResult !== 'object' || combinedParsedResult === null) {
                    throw new Error("Parsed JSON is not an object.");
                }
                if (combinedParsedResult.ingredients && !Array.isArray(combinedParsedResult.ingredients)) {
                    console.warn(`[${requestId}] Gemini returned non-array for ingredients (URL), setting to null.`);
                    combinedParsedResult.ingredients = null;
                }
                if (combinedParsedResult.instructions && !Array.isArray(combinedParsedResult.instructions)) {
                    console.warn(`[${requestId}] Gemini returned non-array for instructions (URL), setting to null.`);
                    combinedParsedResult.instructions = null;
                }
                console.log(`[${requestId}] Successfully parsed combined JSON from Gemini (URL) response.`);
            } catch (parseError: any) {
                console.error(`[${requestId}] Failed to parse JSON response from Gemini (URL Parse):`, parseError);
                console.error(`[${requestId}] Raw Response that failed parsing (URL):`, responseText); 
                processingError = `Invalid JSON received from AI parser for URL: ${parseError.message}`;
            }
        } else {
            processingError = 'Empty response received from AI parser for URL.';
            console.warn(`[${requestId}] Empty response text from Gemini (URL Parse).`);
        }
    } catch (err: any) {
        console.error(`[${requestId}] Error calling Gemini API (URL Parse) or processing result:`, err);
        processingError = err instanceof Error ? err.message : 'An unknown error occurred calling Gemini for URL';
        // Handle blocked content specifically
        if (err?.response?.promptFeedback?.blockReason) {
            processingError = `Gemini blocked the prompt/response for URL: ${err.response.promptFeedback.blockReason}`;
            console.error(`[${requestId}] Gemini prompt/response blocked for URL. Reason: ${err.response.promptFeedback.blockReason}`);
            if (err.response.promptFeedback.safetyRatings) {
                console.error(`[${requestId}] Safety Ratings:`, JSON.stringify(err.response.promptFeedback.safetyRatings, null, 2));
            }
        }
        // Ensure usage is default if error occurs before assignment
        if (usage.inputTokens === 0 && usage.outputTokens === 0) {
            usage = normalizeUsageMetadata(null, 'gemini');
        }
    }


    const geminiCombinedParseTime = Date.now() - geminiCombinedStartTime;
    const totalTime = Date.now() - handlerStartTime;


    if (!processingError && !combinedParsedResult) {
         // This state shouldn't really happen if responseText was non-empty and JSON parsing succeeded but resulted in null/undefined? Add warning.
        console.warn(`[${requestId}] Gemini parsing for URL completed without error, but result is null.`);
        processingError = 'AI parsing completed without error but yielded no result.'; // Assign an error if no recipe found
    }


    console.log(`[${requestId}] Gemini URL content parsing finished. Time=${geminiCombinedParseTime}ms (Total Step Time=${totalTime}ms)`);
    console.log(`[${requestId}] Token Usage (URL Gemini Step): Input=${usage.inputTokens}, Output=${usage.outputTokens}`);


    return {
        recipe: combinedParsedResult,
        error: processingError,
        usage,
        timings: { geminiCombinedParse: geminiCombinedParseTime }
    };
}



===== api/services/textProcessor.ts =====
/**
 * Prepares raw recipe text for further processing.
 * Currently, this just trims the input.
 * @param text The raw recipe text.
 * @param requestId A unique identifier for logging.
 * @returns The prepared text.
 */
export function extractFromRawText(
  text: string,
  requestId: string
): { preparedText: string; error: null; timings: { prepareText: number } } {
  const startTime = Date.now();
  console.log(`[${requestId}] Preparing raw text input.`);
  const preparedText = text.trim();
  const timings = { prepareText: Date.now() - startTime };
  console.log(`[${requestId}] Raw text preparation complete. Timing: ${timings.prepareText}ms`);
  return { preparedText, error: null, timings };
} 

===== api/services/instructionScaling.ts =====
import { performance } from 'perf_hooks';

type LLMResponse<T> = {
  [K in keyof T]: T[K];
} & {
  error: string | null;
  usage: { promptTokens: number; outputTokens: number } | null;
  timeMs: number | null;
};

export async function scaleInstructions(
  instructionsToScale: string[],
  originalIngredients: any[],
  scaledIngredients: any[],
  geminiModel: any
): Promise<LLMResponse<{ scaledInstructions: string[] | null }>> {
  const originalIngredientsDesc = originalIngredients.map((ing: any) => `${ing.amount || ''} ${ing.unit || ''} ${ing.name}`.trim()).join(', ');
  const scaledIngredientsDesc = scaledIngredients.map((ing: any) => `${ing.amount || ''} ${ing.unit || ''} ${ing.name}`.trim()).join(', ');

  const scalePrompt = `
You are an expert recipe editor. Your task is to rewrite recipe instructions to reflect changes in ingredient quantities.

Original ingredients: [${originalIngredientsDesc}]
Scaled ingredients: [${scaledIngredientsDesc}]

Update **only** ingredient quantities that are explicitly stated (e.g., "2 cups flour"). Do not modify vague references like "the onion" or "some salt".

**Rules**:
- Use the exact scaled quantity if numeric.
- For whole or indivisible ingredients (e.g. eggs, bay leaves, cinnamon sticks), round sensibly upwards.
- Be precise. If the original says "Add 2 tbsp olive oil" and the scaled amount is "1 tbsp", rewrite as "Add 1 tbsp olive oil".

Respond with ONLY a valid JSON object:
{
  "scaledInstructions": [ ... ] // same number of steps, rewritten for new quantities
}

Original Instructions:
${instructionsToScale.map(s => `- ${s}`).join('\n')}
`;

  const startTime = performance.now();

  try {
    if (scalePrompt.length > 100000) {
      throw new Error(`Scale prompt too large (${scalePrompt.length} chars).`);
    }

    const result = await geminiModel.generateContent(scalePrompt);
    const response = result.response;
    const responseText = response.text();

    const endTime = performance.now();
    const timeMs = endTime - startTime;

    if (responseText) {
      try {
        const parsedResult: any = JSON.parse(responseText);
        if (parsedResult && Array.isArray(parsedResult.scaledInstructions)) {
          const usage = {
            promptTokens: response.usageMetadata?.promptTokenCount || 0,
            outputTokens: response.usageMetadata?.candidatesTokenCount || 0
          };
          return {
            scaledInstructions: parsedResult.scaledInstructions.map((item: any) => String(item)),
            error: null,
            usage,
            timeMs
          };
        } else {
          throw new Error("Parsed JSON result did not have the expected 'scaledInstructions' array.");
        }
      } catch (parseErr) {
        console.error('Failed to parse scaled instructions JSON from Gemini response:', parseErr);
        console.error('Raw content that failed parsing:', responseText);
        return { scaledInstructions: null, error: 'Invalid JSON format received from AI instruction scaler.', usage: null, timeMs: null };
      }
    } else {
      return { scaledInstructions: null, error: 'Empty response received from AI instruction scaler.', usage: null, timeMs: null };
    }
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown Gemini scale error';
    return { scaledInstructions: null, error: errorMessage, usage: null, timeMs: null };
  }
} 

===== utils/recipeUtils.ts =====
// Import the StructuredIngredient type from the shared types file
import { StructuredIngredient } from '@/api/types';

// --- Fraction Handling ---
// Helper to convert fraction string ("1/2", "3/4") to number
const fractionToDecimal = (fraction: string): number | null => {
  const parts = fraction.split('/');
  if (parts.length !== 2) return null;
  const numerator = parseFloat(parts[0]);
  const denominator = parseFloat(parts[1]);
  if (isNaN(numerator) || isNaN(denominator) || denominator === 0) return null;
  return numerator / denominator;
};

// Helper to find the greatest common divisor (for simplifying fractions)
const gcd = (a: number, b: number): number => {
  return b === 0 ? a : gcd(b, a % b);
};

// --- Main Parsing Function ---
export const parseAmountString = (amountStr: string | null | undefined): number | null => {
  if (amountStr === null || amountStr === undefined || typeof amountStr !== 'string') {
    return null;
  }
  const trimmedAmount = amountStr.trim();
  if (!trimmedAmount || isNaN(parseFloat(trimmedAmount.charAt(0)))) {
    // Handle empty strings or strings not starting with a number (e.g., "to taste")
    return null; 
  }

  // Check for mixed numbers (e.g., "1 1/2")
  const mixedNumberMatch = trimmedAmount.match(/^(\d+)\s+(\d+\/\d+)$/);
  if (mixedNumberMatch) {
    const whole = parseFloat(mixedNumberMatch[1]);
    const fracDecimal = fractionToDecimal(mixedNumberMatch[2]);
    if (fracDecimal !== null) {
      return whole + fracDecimal;
    }
  }

  // Check for simple fractions (e.g., "1/2")
  const fractionMatch = trimmedAmount.match(/^(\d+\/\d+)$/);
  if (fractionMatch) {
    return fractionToDecimal(fractionMatch[1]);
  }

  // Check for simple decimals or whole numbers (e.g., "1.5", "2")
  // Use parseFloat which handles decimals and whole numbers
  const num = parseFloat(trimmedAmount);
  if (!isNaN(num)) {
    return num;
  }
  
  // Handle ranges (e.g., "2-3") - take the first number
  const rangeMatch = trimmedAmount.match(/^(\d+(\.\d+)?)\s*-\s*\d+/);
   if (rangeMatch) {
     const firstNum = parseFloat(rangeMatch[1]);
     if (!isNaN(firstNum)) {
       return firstNum;
     }
   }

  // If none of the above match, it's likely not a standard quantifiable amount
  return null;
};


// --- Formatting Function ---
const FRACTION_MAP: { [key: number]: string } = {
  0.125: '1/8',
  0.25: '1/4',
  0.33: '1/3', 0.333: '1/3', 0.3333: '1/3',
  0.5: '1/2',
  0.66: '2/3', 0.666: '2/3', 0.6667: '2/3',
  0.75: '3/4',
  0.875: '7/8',
};
const FRACTION_PRECISION = 0.01; // How close a decimal needs to be to a known fraction

export const formatAmountNumber = (num: number | null): string | null => {
  if (num === null || isNaN(num)) return null;
  if (num <= 0) return null; // Don't format non-positive numbers typically

  const wholePart = Math.floor(num);
  const decimalPart = num - wholePart;

  let fractionStr = '';

  if (decimalPart > FRACTION_PRECISION) {
    let bestMatch = '';
    let minDiff = 1;

    // Find closest fraction in our map
    for (const decimalVal in FRACTION_MAP) {
      const diff = Math.abs(decimalPart - parseFloat(decimalVal));
      if (diff < FRACTION_PRECISION && diff < minDiff) {
        minDiff = diff;
        bestMatch = FRACTION_MAP[decimalVal];
      }
    }

    if (bestMatch) {
        fractionStr = bestMatch;
    } else {
        // If no close fraction, maybe round to 1 or 2 decimal places?
        // Or attempt to convert to a generic fraction
        const tolerance = 1.0E-6;
        let h1 = 1; let h2 = 0;
        let k1 = 0; let k2 = 1;
        let b = decimalPart;
        do {
            let a = Math.floor(b);
            let aux = h1; h1 = a * h1 + h2; h2 = aux;
            aux = k1; k1 = a * k1 + k2; k2 = aux;
            b = 1 / (b - a);
        } while (Math.abs(decimalPart - h1 / k1) > decimalPart * tolerance && k1 <= 16); // Limit denominator

        if (k1 <= 16) { // Only use if denominator is reasonable
            fractionStr = `${h1}/${k1}`;
        } else {
            // Fallback: Round decimal if no good fraction found
             fractionStr = parseFloat(decimalPart.toFixed(2)).toString(); 
             // Remove leading zero if present (e.g., "0.33" -> ".33") - stylistic choice
             if (fractionStr.startsWith('0.')) {
                 fractionStr = fractionStr.substring(1);
             }
        }
    }
  }

  const wholeStr = wholePart > 0 ? wholePart.toString() : '';
  const separator = wholePart > 0 && fractionStr ? ' ' : '';

  const result = `${wholeStr}${separator}${fractionStr}`;
  return result.trim() || null; // Return null if empty (e.g., input was 0)
};


// --- Scaling Function ---
export const scaleIngredient = (
  ingredient: StructuredIngredient,
  originalServings: number,
  newServings: number
): StructuredIngredient => {
  // Don't scale if servings are invalid or the same
  if (isNaN(originalServings) || originalServings <= 0 || isNaN(newServings) || newServings <= 0 || originalServings === newServings) {
    return ingredient;
  }
    
  const originalAmountNum = parseAmountString(ingredient.amount);

  // Don't scale if amount is not parseable (e.g., "to taste") or zero/negative
  if (originalAmountNum === null || originalAmountNum <= 0) {
    return ingredient;
  }

  const scaleFactor = newServings / originalServings;
  const newAmountNum = originalAmountNum * scaleFactor;

  const newAmountStr = formatAmountNumber(newAmountNum);

  // Return a *new* ingredient object with the updated amount
  return {
    ...ingredient,
    amount: newAmountStr, // Keep unit the same
  };
}; 

===== utils/format.ts =====
export function formatMeasurement(amount: number): string {
  if (isNaN(amount)) return '';

  const FRACTIONS = [
    { value: 1, label: '' },
    { value: 0.875, label: 'â…ž' },
    { value: 0.75, label: 'Â¾' },
    { value: 0.666, label: 'â…”' },
    { value: 0.5, label: 'Â½' },
    { value: 0.333, label: 'â…“' },
    { value: 0.25, label: 'Â¼' },
    { value: 0.125, label: 'â…›' }
  ];

  const whole = Math.floor(amount);
  const decimal = amount - whole;

  let closest = FRACTIONS.reduce((prev, curr) =>
    Math.abs(curr.value - decimal) < Math.abs(prev.value - decimal) ? curr : prev
  );

  if (whole === 0 && closest.value === 1) return '1'; // e.g. 0.99 rounds to 1
  if (closest.value === 0) return `${whole}`;
  return whole > 0 ? `${whole} ${closest.label}` : `${closest.label}`;
} 

===== utils/geminiApi.ts =====
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold, ChatSession, Content } from "@google/generative-ai";

const API_KEY = process.env.EXPO_PUBLIC_GOOGLE_API_KEY;
const MODEL_NAME = "gemini-1.5-flash-latest";

let genAI: GoogleGenerativeAI | null = null;
let model: ChatSession | null = null;

if (API_KEY) {
  genAI = new GoogleGenerativeAI(API_KEY);
  // Initialize the chat session here, or as needed. 
  // For simplicity, we'll re-initialize chat in the function if needed, or maintain one session.
  // Let's create a new chat session for each fresh interaction for now (when history is empty)
} else {
  console.warn("EXPO_PUBLIC_GOOGLE_API_KEY is missing. Help tool will not function properly.");
}

// Gemini API expects history in this format
// type ChatMessage = { role: "user" | "model"; parts: { text: string }[]; };
// This is equivalent to Content[] from the SDK if parts is an array, but parts is an object in Content.
// The SDK's Content type is: export declare type Content = { parts: Part[]; role: string; };
// And Part is: export declare type Part = (TextPart | InlineDataPart | FunctionCallPart | FunctionResponsePart);
// So, { text: string } is a TextPart.

/**
 * Sends a message to the Gemini API and returns the response.
 * @param userMessage The message from the user.
 * @param history The conversation history, conforming to the SDK's Content[] type.
 * @param recipeContext Optional recipe context to prepend for the first message.
 * @returns The bot's response text or null if an error occurs.
 */
export async function sendMessageToGemini(
  userMessage: string,
  history: Content[], // Use Content[] type from SDK
  recipeContext?: {
    instructions: string[];
    substitutions?: string | null;
  }
): Promise<string | null> {
  if (!genAI) {
    console.error("Gemini AI SDK is not initialized (API key might be missing).");
    return "Error: Help feature is not available (API key missing or SDK init failed).";
  }

  let promptForApi = userMessage;
  let historyForApi: Content[] = [...history]; // history is empty on first call from HelpTool normally

  // Define safetySettings here so it's in scope for the model initialization
  const safetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  ];

  if (history.length === 0 && recipeContext) {
    console.log("Constructing initial history with recipe context.");
    let contextText = "You are a friendly and helpful recipe assistant. \n";
    contextText += "The user is currently working on the following recipe:\n\n";
    contextText += "Instructions:\n";
    recipeContext.instructions.forEach((step, index) => {
      contextText += `${index + 1}. ${step}\n`;
    });
    if (recipeContext.substitutions) {
      contextText += `\nNotes on substitutions: ${recipeContext.substitutions}\n`;
    }
    contextText += "\n--- END OF RECIPE CONTEXT ---\n\n";
    contextText += "Now, please answer the user's question about this recipe. Be concise and helpful.\n";
    
    // New approach: Add context as the first "user" message in history, then the actual user question follows.
    // Or, more robustly, provide it as a system message if the model/SDK supports distinct system roles.
    // For now, let's make the context part of the initial history. The model should understand the structure.
    historyForApi = [
      { role: "user", parts: [{ text: contextText }] }, 
      // The actual first user message will be sent via chat.sendMessage(userMessage)
      // Or, if the model expects the first *actual* user message after context in history:
      // { role: "user", parts: [{ text: userMessage }] }
      // Let's try with context as a user turn, then the actual userMessage as the prompt to sendMessage.
    ];
    promptForApi = userMessage; // The prompt to sendMessage is just the user's current utterance.
    // If the above doesn't work, an alternative is one big initial user message:
    // promptForApi = `${contextText}\nUser question: ${userMessage}`;
    // historyForApi = []; // And history is empty
  }

  // console.log("[geminiApi] History for API:", JSON.stringify(historyForApi, null, 2));
  console.log("[geminiApi] Prompt for API (sendMessage):", promptForApi);

  try {
    // Initialize the model and start chat here
    const generativeModel = genAI.getGenerativeModel({ model: MODEL_NAME, safetySettings });
    const chat = generativeModel.startChat({
        history: historyForApi,
        generationConfig: {
            // maxOutputTokens: 200, 
        },
    });

    const result = await chat.sendMessage(promptForApi);
    const response = result.response;
    const text = response.text();
    
    // console.log("Gemini Response:", text);
    return text;

  } catch (error) {
    console.error("Error calling Gemini API:", error);
    // Check for specific error types if needed, e.g., blocked prompts
    if (error instanceof Error && error.message.includes("SAFETY")) {
        return "Sorry, your request was blocked due to safety settings. Please rephrase your question.";
    }
    return "Sorry, I encountered an error trying to get a response. Please try again later.";
  }
} 

===== utils/units.ts =====
// Basic Unit Conversion Logic
// Focus on common cooking units (volume primarily)
// Could be expanded significantly or use a library for more robustness

// Base unit: Milliliters (ml)
const conversions: { [key: string]: number } = {
  ml: 1,
  tsp: 4.92892,       // US teaspoon
  tbsp: 14.7868,      // US tablespoon (3 tsp)
  fl_oz: 29.5735,     // US fluid ounce (2 tbsp)
  cup: 236.588,       // US cup (16 tbsp or 8 fl oz)
  pint: 473.176,      // US pint (2 cups)
  quart: 946.353,     // US quart (4 cups or 2 pints)
  gallon: 3785.41,    // US gallon (4 quarts)
  liter: 1000,       // Metric liter
  // Weight (approximate for common liquids like water/milk - very inaccurate for solids)
  // It's generally better NOT to convert between volume and weight without density info
  // g: 1,            // Gram (base for weight)
  // kg: 1000,
  // oz: 28.3495,     // Ounce (weight)
  // lb: 453.592,     // Pound (weight)
};

export type Unit = keyof typeof conversions;

export const availableUnits = Object.keys(conversions) as Unit[];

export function convertUnits(amount: number, fromUnit: Unit, toUnit: Unit): number | null {
  if (isNaN(amount) || amount < 0) {
    return null;
  }
  if (!conversions[fromUnit] || !conversions[toUnit]) {
    console.error(`Unknown unit(s): ${fromUnit}, ${toUnit}`);
    return null; // Unknown unit
  }

  // Convert 'fromUnit' to base unit (ml)
  const amountInMl = amount * conversions[fromUnit];

  // Convert from base unit (ml) to 'toUnit'
  const result = amountInMl / conversions[toUnit];

  // Basic rounding for display purposes
  if (result < 0.1 && result > 0) {
      return parseFloat(result.toFixed(3));
  }
  if (result < 1 && result > 0) {
      return parseFloat(result.toFixed(2));
  }
  return parseFloat(result.toFixed(1));
}

// Helper to get common display names (can be expanded)
export function getUnitDisplayName(unit: Unit): string {
    switch (unit) {
        case 'ml': return 'ml';
        case 'tsp': return 'tsp';
        case 'tbsp': return 'tbsp';
        case 'fl_oz': return 'fl oz';
        case 'cup': return 'cups';
        case 'pint': return 'pints';
        case 'quart': return 'quarts';
        case 'gallon': return 'gallons';
        case 'liter': return 'liters';
        default:
            // Explicitly cast unit to string for the default case
            return String(unit);
    }
} 

